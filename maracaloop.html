<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Loopstation 8 Tracce (MediaRecorder)</title>
  <style>
    :root{
      --bg:#0f1115; --text:#e7ecff; --muted:#a7b0d6;
      --stroke:#2a3247; --stroke2:#1c2232; --shadow:0 10px 30px rgba(0,0,0,.45);
      --red:#ff3b3b; --green:#44ff9a; --cyan:#4ee6ff;
      --radius:18px;
    }
    *{box-sizing:border-box}
    body{
      margin:0; color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      background: radial-gradient(1200px 700px at 30% 15%, #1a2240 0%, rgba(26,34,64,0) 55%),
                  radial-gradient(900px 500px at 80% 30%, #1a3a2f 0%, rgba(26,58,47,0) 55%),
                  var(--bg);
      min-height:100vh; display:flex; flex-direction:column; align-items:center;
    }
    header{
      width:min(1100px, 94vw); padding:22px 10px 10px;
      display:flex; align-items:flex-end; justify-content:space-between; gap:14px;
    }
    .title{font-size:28px; letter-spacing:.08em; font-weight:700; opacity:.95;}
    .top-controls{display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; align-items:center;}
    .btn{
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      color:var(--text); padding:10px 12px; border-radius:12px;
      box-shadow: 0 6px 18px rgba(0,0,0,.25);
      cursor:pointer; user-select:none;
    }
    .btn:hover{filter:brightness(1.06); border-color:#3a4566;}
    .btn:disabled{opacity:.45; cursor:not-allowed;}
    .btn-primary{border-color:rgba(78,230,255,.35);}
    .btn-good{border-color:rgba(68,255,154,.35);}
    .btn-danger{border-color:rgba(255,59,59,.35);}
    .pill{
      padding:9px 12px; border-radius:999px; border:1px solid var(--stroke);
      background: rgba(255,255,255,.03); color:var(--muted); display:flex; align-items:center; gap:10px;
    }
    .pill select{
      background: rgba(0,0,0,.25); border:1px solid var(--stroke2);
      color:var(--text); padding:7px 10px; border-radius:10px; outline:none;
    }
    .statusbar{
      width:min(1100px, 94vw); padding:0 10px 16px;
      display:flex; gap:12px; flex-wrap:wrap; align-items:center; color:var(--muted);
    }
    .badge{
      padding:6px 10px; border:1px solid var(--stroke); background: rgba(0,0,0,.18);
      border-radius:999px; display:inline-flex; align-items:center; gap:8px;
    }
    .dot{width:10px;height:10px;border-radius:50%;background:#666; box-shadow:0 0 0 2px rgba(255,255,255,.06) inset;}
    .dot.on{background:var(--green);}
    .dot.rec{background:var(--red);}
    .dot.play{background:var(--cyan);}

    main{
      width:min(1100px, 94vw); padding:0 10px 26px;
      display:grid; grid-template-columns:repeat(4, minmax(0, 1fr)); gap:16px;
    }
    @media (max-width: 980px){ main{grid-template-columns:repeat(2, minmax(0, 1fr));} }
    @media (max-width: 520px){ main{grid-template-columns:1fr;} }

    .track{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid var(--stroke); border-radius:var(--radius);
      box-shadow:var(--shadow); padding:14px; position:relative; overflow:hidden;
    }
    .track::before{
      content:""; position:absolute; inset:-30% -40%;
      background: radial-gradient(400px 220px at 40% 35%, rgba(78,230,255,.08), rgba(0,0,0,0) 60%),
                  radial-gradient(360px 240px at 70% 65%, rgba(68,255,154,.06), rgba(0,0,0,0) 60%);
      pointer-events:none; transform:rotate(-8deg);
    }
    .track > *{position:relative;}
    .track-head{display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px;}
    .track-title{display:flex; align-items:baseline; gap:10px;}
    .track-title .n{font-weight:800; font-size:18px; opacity:.95;}
    .track-title .label{font-size:13px; color:var(--muted);}
    .mini{display:flex; gap:8px; align-items:center;}
    .tag{
      font-size:12px; padding:4px 8px; border:1px solid var(--stroke2);
      border-radius:999px; color:var(--muted); background: rgba(0,0,0,.22);
      letter-spacing:.04em; text-transform:uppercase;
    }
    .tag.rec{border-color:rgba(255,59,59,.35); color:#ffd0d0;}
    .tag.play{border-color:rgba(78,230,255,.35); color:#d6fbff;}
    .tag.stop{border-color:rgba(167,176,214,.35); color:var(--muted);}

    .track-body{display:grid; grid-template-columns:1fr 64px; gap:12px; align-items:center;}
    .big-btn{
      width:118px; height:118px; border-radius:999px; margin:6px auto 0;
      border:1px solid rgba(255,255,255,.10);
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.12), rgba(0,0,0,.25) 60%),
                  rgba(0,0,0,.20);
      display:grid; place-items:center; cursor:pointer; user-select:none;
      box-shadow:0 18px 40px rgba(0,0,0,.45); position:relative;
    }
    .big-btn .ring{position:absolute; inset:-8px; border-radius:999px; border:10px solid rgba(255,59,59,.75);
      border-top-color:rgba(255,59,59,.18); border-left-color:rgba(255,59,59,.45); opacity:.85;}
    .big-btn .ring2{position:absolute; inset:10px; border-radius:999px; border:6px solid rgba(68,255,154,.55);
      border-right-color:rgba(68,255,154,.15); border-bottom-color:rgba(68,255,154,.35); opacity:.85;}
    .icon{
      width:54px; height:54px; border-radius:999px; display:grid; place-items:center;
      background: rgba(0,0,0,.35); border:1px solid rgba(255,255,255,.10);
    }
    .big-btn svg{width:30px; height:30px; fill:none; stroke-width:2.4;}
    .fader{
      display:flex; flex-direction:column; align-items:center; gap:8px;
      padding:8px 6px; border-radius:14px; border:1px solid var(--stroke2); background: rgba(0,0,0,.18);
    }
    .fader label{font-size:12px; color:var(--muted);}
    input[type="range"]{
      -webkit-appearance:none; appearance:none;
      width:140px; height:10px; border-radius:999px; background: rgba(255,255,255,.10);
      outline:none; transform: rotate(-90deg); margin:54px 0;
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none; appearance:none;
      width:18px; height:18px; border-radius:50%;
      background: rgba(255,255,255,.85); border:2px solid rgba(0,0,0,.35);
      box-shadow:0 6px 18px rgba(0,0,0,.45); cursor:pointer;
    }
    .track-actions{display:flex; gap:8px; margin-top:12px; justify-content:space-between;}
    .track-actions .btn{padding:9px 10px; border-radius:12px; flex:1; justify-content:center;}
    .footer-note{width:min(1100px, 94vw); padding:0 10px 26px; color:var(--muted); font-size:13px; line-height:1.4;}
    code{background:rgba(0,0,0,.25); padding:2px 6px; border-radius:8px; border:1px solid var(--stroke2);}
  </style>
</head>
<body>
  <header>
    <div class="title">maracaloop A</div>
    <div class="top-controls">
      <div class="pill">
        <span>Sorgente</span>
        <select id="sourceSelect" aria-label="Sorgente audio">
          <option value="mic">Microfono</option>
          <option value="screen">Scheda/Schermo con audio (se supportato)</option>
        </select>
      </div>
      <button class="btn btn-primary" id="btnInit">1) Attiva Audio</button>
      <button class="btn btn-good" id="btnPlayAll" disabled>Play All</button>
      <button class="btn btn-danger" id="btnStopAll" disabled>Stop All</button>
      <button class="btn" id="btnClearAll" disabled>Clear All</button>
    </div>
  </header>

  <div class="statusbar">
    <div class="badge"><span class="dot" id="dotAudio"></span> AudioContext</div>
    <div class="badge"><span class="dot" id="dotInput"></span> Ingresso</div>
    <div class="badge">Loop master: <b id="masterLen">—</b></div>
    <div class="badge">SampleRate: <b id="sr">—</b></div>
    <div class="badge">Codec REC: <b id="codec">—</b></div>
  </div>

  <main id="grid"></main>

  <div class="footer-note">
    <ul>
      <li>Apri da <code>https://</code> o <code>http://localhost</code>. Evita <code>file://</code>.</li>
      <li>La <b>prima traccia registrata</b> definisce la durata master. Le altre vengono adattate a quella durata.</li>
      <li>“Scheda/Schermo con audio” dipende dal browser/OS: su Chrome desktop funziona bene con “Condividi scheda” + audio.</li>
    </ul>
  </div>

<script>
(() => {
  const TRACKS = 8;

  let audioCtx = null;
  let inputStream = null;
  let inputNode = null;
  let masterGain = null;

  let masterLoopSeconds = null;

  const grid = document.getElementById("grid");
  const btnInit = document.getElementById("btnInit");
  const btnPlayAll = document.getElementById("btnPlayAll");
  const btnStopAll = document.getElementById("btnStopAll");
  const btnClearAll = document.getElementById("btnClearAll");
  const sourceSelect = document.getElementById("sourceSelect");

  const dotAudio = document.getElementById("dotAudio");
  const dotInput = document.getElementById("dotInput");
  const masterLenEl = document.getElementById("masterLen");
  const srEl = document.getElementById("sr");
  const codecEl = document.getElementById("codec");

  const tracks = [];

  function fmtSec(s){
    if (s == null || !isFinite(s)) return "—";
    return (s < 10 ? s.toFixed(2) : s.toFixed(1)) + "s";
  }

  function setDots(){
    dotAudio.classList.toggle("on", !!audioCtx && audioCtx.state === "running");
    dotInput.classList.toggle("on", !!inputStream);
  }

  function setMasterLoop(seconds){
    masterLoopSeconds = seconds;
    masterLenEl.textContent = fmtSec(masterLoopSeconds);
  }

  function updateGlobalButtons(){
    const anyHasBuffer = tracks.some(t => !!t.buffer);
    const anyPlaying = tracks.some(t => t.isPlaying);
    btnPlayAll.disabled = !audioCtx || !anyHasBuffer;
    btnStopAll.disabled = !audioCtx || (!anyPlaying && !tracks.some(t => t.isRecording));
    btnClearAll.disabled = !audioCtx || !anyHasBuffer;
  }

  function pickBestMimeType(){
    // Prefer opus in webm, fallback to mp4 if available (iOS Safari tends to mp4; Chrome usually webm/opus).
    const candidates = [
      'audio/webm;codecs=opus',
      'audio/webm',
      'audio/mp4',
      'audio/ogg;codecs=opus',
      'audio/ogg'
    ];
    for (const c of candidates){
      if (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(c)) return c;
    }
    return ''; // let browser choose
  }

  async function getInputStream(){
    const mode = sourceSelect.value;
    if (mode === "mic"){
      return await navigator.mediaDevices.getUserMedia({
        audio: { echoCancellation:false, noiseSuppression:false, autoGainControl:false },
        video: false
      });
    }
    // Screen/tab audio (support varies; on Chrome Desktop, "tab audio" works well)
    return await navigator.mediaDevices.getDisplayMedia({ audio:true, video:true });
  }

  function stopAllInput(){
    if (inputStream){
      for (const tr of inputStream.getTracks()) tr.stop();
      inputStream = null;
    }
    inputNode = null;
  }

  function createTrack(index){
    return {
      index,
      buffer: null,
      source: null,
      gainNode: null,

      recorder: null,
      recChunks: [],
      isRecording: false,
      isPlaying: false,

      ui: {}
    };
  }

  function stopPlayback(t){
    if (t.source){
      try { t.source.stop(); } catch {}
      try { t.source.disconnect(); } catch {}
      t.source = null;
    }
    t.isPlaying = false;
    updateTrackUI(t);
    updateGlobalButtons();
  }

  function startPlayback(t){
    if (!audioCtx || !t.buffer) return;

    stopPlayback(t);
    const src = audioCtx.createBufferSource();
    src.buffer = t.buffer;
    src.loop = true;
    src.loopStart = 0;
    src.loopEnd = t.buffer.duration;
    src.connect(t.gainNode);
    src.start();
    t.source = src;
    t.isPlaying = true;
    updateTrackUI(t);
    updateGlobalButtons();
  }

  function clearTrack(t){
    if (t.isRecording) stopRecording(t);
    stopPlayback(t);
    t.buffer = null;
    updateTrackUI(t);
    updateGlobalButtons();
  }

  function quantizeToMasterBuffer(buf){
    if (masterLoopSeconds == null) return buf;
    const sr = buf.sampleRate;
    const targetFrames = Math.max(1, Math.round(masterLoopSeconds * sr));
    const chs = buf.numberOfChannels;
    const out = audioCtx.createBuffer(chs, targetFrames, sr);

    for (let ch=0; ch<chs; ch++){
      const inData = buf.getChannelData(ch);
      const outData = out.getChannelData(ch);
      if (inData.length >= targetFrames){
        outData.set(inData.subarray(0, targetFrames));
      } else {
        outData.set(inData);
        // rest stays zero (padding)
      }
    }
    return out;
  }

  async function blobToAudioBuffer(blob){
    const arrayBuf = await blob.arrayBuffer();
    // decodeAudioData returns AudioBuffer
    return await audioCtx.decodeAudioData(arrayBuf);
  }

  function startRecording(t){
    if (!audioCtx || !inputStream) return;
    if (!window.MediaRecorder) {
      alert("MediaRecorder non disponibile in questo browser.");
      return;
    }
    if (t.isRecording) return;

    // If already had content, we replace it (no overdub in this version)
    stopPlayback(t);

    t.recChunks = [];
    const mime = pickBestMimeType();
    codecEl.textContent = mime || "(auto)";
    let rec;
    try{
      rec = new MediaRecorder(inputStream, mime ? { mimeType: mime } : undefined);
    } catch (e){
      // fallback: try without options
      rec = new MediaRecorder(inputStream);
      codecEl.textContent = "(fallback)";
    }

    t.recorder = rec;
    t.isRecording = true;

    rec.ondataavailable = (ev) => {
      if (ev.data && ev.data.size > 0) t.recChunks.push(ev.data);
    };
    rec.onerror = (ev) => {
      console.error("Recorder error", ev);
      alert("Errore registrazione: " + (ev?.error?.message || ev?.message || ev));
      t.isRecording = false;
      updateTrackUI(t);
      updateGlobalButtons();
    };
    rec.onstop = async () => {
      try{
        const blob = new Blob(t.recChunks, { type: rec.mimeType || 'audio/webm' });
        if (blob.size < 2000){
          // too small
          t.buffer = null;
          t.isRecording = false;
          updateTrackUI(t);
          updateGlobalButtons();
          return;
        }

        const decoded = await blobToAudioBuffer(blob);

        // Use mono mixdown if multi-channel (optional)
        let buf = decoded;
        if (decoded.numberOfChannels > 1){
          const mono = audioCtx.createBuffer(1, decoded.length, decoded.sampleRate);
          const out = mono.getChannelData(0);
          // simple average
          for (let ch=0; ch<decoded.numberOfChannels; ch++){
            const d = decoded.getChannelData(ch);
            for (let i=0; i<d.length; i++) out[i] += d[i] / decoded.numberOfChannels;
          }
          buf = mono;
        }

        if (masterLoopSeconds == null){
          setMasterLoop(buf.duration);
          t.buffer = buf;
        } else {
          t.buffer = quantizeToMasterBuffer(buf);
        }
      } catch (e){
        console.error(e);
        alert("Errore decodifica audio: " + (e?.message || e));
      } finally {
        t.isRecording = false;
        t.recorder = null;
        t.recChunks = [];
        updateTrackUI(t);
        updateGlobalButtons();
      }
    };

    // start
    try{
      rec.start(250); // timeslice: smoother on some devices
    } catch (e){
      console.error(e);
      alert("Impossibile avviare registrazione: " + (e?.message || e));
      t.isRecording = false;
      t.recorder = null;
    }

    updateTrackUI(t);
    updateGlobalButtons();
  }

  function stopRecording(t){
    if (!t.recorder || !t.isRecording) return;
    try{
      t.recorder.stop();
    } catch {}
    // onstop will finalize buffer
    updateTrackUI(t);
    updateGlobalButtons();
  }

  function toggleMainButton(t){
    // Empty -> REC/STOP REC
    // Has buffer -> PLAY/STOP
    if (!t.buffer){
      if (!t.isRecording) startRecording(t);
      else stopRecording(t);
    } else {
      if (!t.isPlaying) startPlayback(t);
      else stopPlayback(t);
    }
  }

  function updateTrackUI(t){
    const { btnMain, tag, label, dot, vol, volpct, muteBtn, clearBtn } = t.ui;

    if (t.isRecording){
      tag.textContent = "REC";
      tag.className = "tag rec";
      dot.className = "dot rec";
      label.textContent = "registrazione…";
    } else if (t.isPlaying){
      tag.textContent = "PLAY";
      tag.className = "tag play";
      dot.className = "dot play";
      label.textContent = "in loop";
    } else {
      tag.textContent = "STOP";
      tag.className = "tag stop";
      dot.className = "dot";
      label.textContent = t.buffer ? ("pronto • " + fmtSec(t.buffer.duration)) : "vuoto";
    }

    const svg = btnMain.querySelector("svg");
    const path = svg.querySelector("path");

    if (!t.buffer){
      if (t.isRecording){
        path.setAttribute("d", "M9 9h14v14H9z"); // stop square
        svg.style.stroke = "rgba(255,59,59,.95)";
      } else {
        path.setAttribute("d", "M16 10a6 6 0 1 0 0 12a6 6 0 0 0 0-12Z"); // record circle
        svg.style.stroke = "rgba(255,59,59,.95)";
      }
    } else {
      if (t.isPlaying){
        path.setAttribute("d", "M9 9h14v14H9z"); // stop
        svg.style.stroke = "rgba(78,230,255,.95)";
      } else {
        path.setAttribute("d", "M12 10l12 6-12 6V10z"); // play
        svg.style.stroke = "rgba(68,255,154,.95)";
      }
    }

    clearBtn.disabled = (!t.buffer && !t.isRecording);
    muteBtn.disabled = !t.gainNode;

    const v = parseFloat(vol.value);
    volpct.textContent = Math.round(v*100) + "%";
  }

  function buildTrackCard(t){
    const el = document.createElement("section");
    el.className = "track";
    el.innerHTML = `
      <div class="track-head">
        <div class="track-title">
          <div class="n">${t.index+1}</div>
          <div class="label" id="label">vuoto</div>
        </div>
        <div class="mini">
          <span class="dot" id="dot"></span>
          <span class="tag stop" id="tag">STOP</span>
        </div>
      </div>

      <div class="track-body">
        <div style="text-align:center;">
          <div class="big-btn" id="btnMain" role="button" tabindex="0" aria-label="Record/Play">
            <div class="ring"></div>
            <div class="ring2"></div>
            <div class="icon">
              <svg viewBox="0 0 32 32" stroke="rgba(255,59,59,.95)">
                <path d="M16 10a6 6 0 1 0 0 12a6 6 0 0 0 0-12Z"></path>
              </svg>
            </div>
          </div>
        </div>

        <div class="fader">
          <label>VOL</label>
          <input id="vol" type="range" min="0" max="1" step="0.01" value="0.85" />
          <label id="volpct">85%</label>
        </div>
      </div>

      <div class="track-actions">
        <button class="btn" id="muteBtn">Mute</button>
        <button class="btn" id="clearBtn">Clear</button>
      </div>
    `;

    const btnMain = el.querySelector("#btnMain");
    const tag = el.querySelector("#tag");
    const label = el.querySelector("#label");
    const dot = el.querySelector("#dot");
    const vol = el.querySelector("#vol");
    const volpct = el.querySelector("#volpct");
    const muteBtn = el.querySelector("#muteBtn");
    const clearBtn = el.querySelector("#clearBtn");

    t.ui = { el, btnMain, tag, label, dot, vol, volpct, muteBtn, clearBtn };

    btnMain.addEventListener("click", async () => {
      if (!audioCtx) return alert("Prima clicca: Attiva Audio");
      // Ensure audio context running (mobile may suspend)
      try { await audioCtx.resume(); } catch {}
      toggleMainButton(t);
    });
    btnMain.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") { e.preventDefault(); btnMain.click(); }
    });

    vol.addEventListener("input", () => {
      const v = parseFloat(vol.value);
      if (t.gainNode) t.gainNode.gain.value = v;
      updateTrackUI(t);
    });

    muteBtn.addEventListener("click", () => {
      if (!t.gainNode) return;
      const currently = t.gainNode.gain.value;
      if (currently > 0.0001){
        t._prevVol = parseFloat(vol.value);
        t.gainNode.gain.value = 0;
        vol.value = "0";
      } else {
        const pv = (t._prevVol != null) ? t._prevVol : 0.85;
        t.gainNode.gain.value = pv;
        vol.value = String(pv);
      }
      vol.dispatchEvent(new Event("input"));
    });

    clearBtn.addEventListener("click", () => clearTrack(t));

    updateTrackUI(t);
    return el;
  }

  function buildUI(){
    grid.innerHTML = "";
    tracks.length = 0;
    for (let i=0; i<TRACKS; i++){
      const t = createTrack(i);
      tracks.push(t);
      grid.appendChild(buildTrackCard(t));
    }
    updateGlobalButtons();
  }

  async function initAudio(){
    if (audioCtx) return;

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    srEl.textContent = audioCtx.sampleRate + " Hz";

    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.95;
    masterGain.connect(audioCtx.destination);

    // Ask user for input stream
    inputStream = await getInputStream();

    // If screen capture includes video, we don't need it; but keep it running for audio to continue.
    // Create input node for monitoring/optional future processing (not routed to output to avoid feedback).
    inputNode = audioCtx.createMediaStreamSource(inputStream);

    // Track gains
    for (const t of tracks){
      t.gainNode = audioCtx.createGain();
      t.gainNode.gain.value = parseFloat(t.ui.vol.value);
      t.gainNode.connect(masterGain);
    }

    await audioCtx.resume();
    setDots();

    btnInit.textContent = "Audio attivo";
    btnInit.disabled = true;

    updateGlobalButtons();
  }

  // Global controls
  btnInit.addEventListener("click", async () => {
    try{
      await initAudio();
    } catch (e){
      console.error(e);
      alert("Impossibile attivare audio: " + (e?.message || e));
      stopAllInput();
    } finally {
      setDots();
      updateGlobalButtons();
    }
  });

  btnPlayAll.addEventListener("click", () => {
    for (const t of tracks) if (t.buffer && !t.isPlaying) startPlayback(t);
    updateGlobalButtons();
  });

  btnStopAll.addEventListener("click", () => {
    for (const t of tracks){
      if (t.isRecording) stopRecording(t);
      if (t.isPlaying) stopPlayback(t);
    }
    updateGlobalButtons();
  });

  btnClearAll.addEventListener("click", () => {
    if (!confirm("Cancellare tutte le tracce?")) return;
    for (const t of tracks) clearTrack(t);
    masterLoopSeconds = null;
    masterLenEl.textContent = "—";
    updateGlobalButtons();
  });

  sourceSelect.addEventListener("change", () => {
    if (audioCtx){
      alert("Hai cambiato sorgente. Ricarica la pagina per applicarla.");
    }
  });

  // Init UI
  buildUI();

  // Dots refresh
  setInterval(() => {
    setDots();
  }, 500);
})();
</script>
</body>
</html>
