<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Loopstation 8 Tracce + Metronomo (Chrome Android/Desktop)</title>
  <title>Loopstation 8 Tracce + Metronomo + Sync Grid</title>
<style>
:root{
--bg:#0f1115; --text:#e7ecff; --muted:#a7b0d6;
--stroke:#2a3247; --stroke2:#1c2232; --shadow:0 10px 30px rgba(0,0,0,.45);
--red:#ff3b3b; --green:#44ff9a; --cyan:#4ee6ff;
--radius:18px;
}
*{box-sizing:border-box}
body{
margin:0; color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
background: radial-gradient(1200px 700px at 30% 15%, #1a2240 0%, rgba(26,34,64,0) 55%),
radial-gradient(900px 500px at 80% 30%, #1a3a2f 0%, rgba(26,58,47,0) 55%),
var(--bg);
min-height:100vh; display:flex; flex-direction:column; align-items:center;
}

header{
width:min(1100px, 94vw); padding:18px 10px 8px;
display:flex; align-items:flex-end; justify-content:space-between; gap:14px;
}
.title{font-size:28px; letter-spacing:.08em; font-weight:700; opacity:.95;}
.top-controls{display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; align-items:center;}

.btn{
border:1px solid var(--stroke);
background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
color:var(--text); padding:10px 12px; border-radius:12px;
box-shadow: 0 6px 18px rgba(0,0,0,.25);
cursor:pointer; user-select:none;
}
.btn:hover{filter:brightness(1.06); border-color:#3a4566;}
.btn:disabled{opacity:.45; cursor:not-allowed;}
.btn-primary{border-color:rgba(78,230,255,.35);}
.btn-good{border-color:rgba(68,255,154,.35);}
.btn-danger{border-color:rgba(255,59,59,.35);}

.pill{
padding:9px 12px; border-radius:999px; border:1px solid var(--stroke);
background: rgba(255,255,255,.03); color:var(--muted); display:flex; align-items:center; gap:10px;
}
.pill select{
background: rgba(0,0,0,.25); border:1px solid var(--stroke2);
color:var(--text); padding:7px 10px; border-radius:10px; outline:none;
}

/* Metronome panel */
    .metro-wrap{
      width:min(1100px, 94vw);
      padding: 0 10px 14px;
    }
    .metro-wrap{ width:min(1100px, 94vw); padding: 0 10px 14px; }
.metro{
border:1px solid var(--stroke);
border-radius: var(--radius);
background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
box-shadow: var(--shadow);
padding: 12px 14px;
      display:flex;
      flex-wrap:wrap;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      display:flex; flex-wrap:wrap; gap:12px;
      align-items:center; justify-content:space-between;
}
.metro-left{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
.metro-right{display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:flex-end;}

.metro-group{
display:flex; gap:10px; flex-wrap:wrap; align-items:center;
      padding:8px 10px;
      border:1px solid var(--stroke2);
      border-radius:14px;
      background: rgba(0,0,0,.18);
      padding:8px 10px; border:1px solid var(--stroke2);
      border-radius:14px; background: rgba(0,0,0,.18);
}
.metro-group label{font-size:12px; color:var(--muted);}
.metro-group input[type="range"]{width:160px; height:10px; margin:0; transform:none;}
.metro-group input[type="range"]{
-webkit-appearance:none; appearance:none;
border-radius:999px; background: rgba(255,255,255,.10);
outline:none;
}
.metro-group input[type="range"]::-webkit-slider-thumb{
-webkit-appearance:none; appearance:none;
width:18px; height:18px; border-radius:50%;
background: rgba(255,255,255,.85); border:2px solid rgba(0,0,0,.35);
box-shadow:0 6px 18px rgba(0,0,0,.45); cursor:pointer;
}
.bpm{font-weight:700; min-width:64px; text-align:right;}

.leds{display:flex; gap:8px; align-items:center;}
.led{
width:12px; height:12px; border-radius:50%;
background:#3a3f52;
box-shadow: 0 0 0 2px rgba(255,255,255,.06) inset;
transition: transform .06s ease, filter .06s ease;
}
.led.on{
background: var(--cyan);
filter: drop-shadow(0 0 10px rgba(78,230,255,.65));
transform: scale(1.15);
}
.led.bar{
width:14px; height:14px;
background:#4a1f1f;
}
.led.bar.on{
background: var(--red);
filter: drop-shadow(0 0 12px rgba(255,59,59,.75));
transform: scale(1.2);
}

.countin{
font-size:12px;
color: var(--muted);
padding:6px 10px;
border:1px solid var(--stroke2);
border-radius:999px;
background: rgba(0,0,0,.22);
      min-width: 190px;
      min-width: 210px;
text-align:center;
      user-select:none;
}
.countin.active{
color:#ffd0d0;
border-color: rgba(255,59,59,.35);
background: rgba(255,59,59,.08);
box-shadow: 0 0 18px rgba(255,59,59,.10);
}

.statusbar{
width:min(1100px, 94vw); padding:0 10px 16px;
display:flex; gap:12px; flex-wrap:wrap; align-items:center; color:var(--muted);
}
.badge{
padding:6px 10px; border:1px solid var(--stroke); background: rgba(0,0,0,.18);
border-radius:999px; display:inline-flex; align-items:center; gap:8px;
}
.dot{width:10px;height:10px;border-radius:50%;background:#666; box-shadow:0 0 0 2px rgba(255,255,255,.06) inset;}
.dot.on{background:var(--green);}
.dot.rec{background:var(--red);}
.dot.play{background:var(--cyan);}

main{
width:min(1100px, 94vw); padding:0 10px 26px;
display:grid; grid-template-columns:repeat(4, minmax(0, 1fr)); gap:16px;
}
@media (max-width: 980px){ main{grid-template-columns:repeat(2, minmax(0, 1fr));} }
@media (max-width: 520px){ main{grid-template-columns:1fr;} }

.track{
background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
border:1px solid var(--stroke); border-radius:var(--radius);
box-shadow:var(--shadow); padding:14px; position:relative; overflow:hidden;
touch-action: manipulation;
}
.track::before{
content:""; position:absolute; inset:-30% -40%;
background: radial-gradient(400px 220px at 40% 35%, rgba(78,230,255,.08), rgba(0,0,0,0) 60%),
radial-gradient(360px 240px at 70% 65%, rgba(68,255,154,.06), rgba(0,0,0,0) 60%);
pointer-events:none; transform:rotate(-8deg);
}
.track > *{position:relative;}
.track-head{display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px;}
.track-title{display:flex; align-items:baseline; gap:10px;}
.track-title .n{font-weight:800; font-size:18px; opacity:.95;}
.track-title .label{font-size:13px; color:var(--muted);}
.mini{display:flex; gap:8px; align-items:center;}
.tag{
font-size:12px; padding:4px 8px; border:1px solid var(--stroke2);
border-radius:999px; color:var(--muted); background: rgba(0,0,0,.22);
letter-spacing:.04em; text-transform:uppercase;
}
.tag.rec{border-color:rgba(255,59,59,.35); color:#ffd0d0;}
.tag.play{border-color:rgba(78,230,255,.35); color:#d6fbff;}
.tag.stop{border-color:rgba(167,176,214,.35); color:var(--muted);}
.tag.count{border-color:rgba(255,59,59,.35); color:#ffd0d0;}

.track-body{display:grid; grid-template-columns:1fr 64px; gap:12px; align-items:center;}

.big-btn{
width:118px; height:118px; border-radius:999px; margin:6px auto 0;
border:1px solid rgba(255,255,255,.10);
background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.12), rgba(0,0,0,.25) 60%),
rgba(0,0,0,.20);
display:grid; place-items:center; cursor:pointer; user-select:none;
box-shadow:0 18px 40px rgba(0,0,0,.45); position:relative;
}
.big-btn .ring{position:absolute; inset:-8px; border-radius:999px; border:10px solid rgba(255,59,59,.75);
border-top-color:rgba(255,59,59,.18); border-left-color:rgba(255,59,59,.45); opacity:.85;}
.big-btn .ring2{position:absolute; inset:10px; border-radius:999px; border:6px solid rgba(68,255,154,.55);
border-right-color:rgba(68,255,154,.15); border-bottom-color:rgba(68,255,154,.35); opacity:.85;}
.icon{
width:54px; height:54px; border-radius:999px; display:grid; place-items:center;
background: rgba(0,0,0,.35); border:1px solid rgba(255,255,255,.10);
}
.big-btn svg{width:30px; height:30px; fill:none; stroke-width:2.4;}

.fader{
display:flex; flex-direction:column; align-items:center; gap:8px;
padding:8px 6px; border-radius:14px; border:1px solid var(--stroke2); background: rgba(0,0,0,.18);
}
.fader label{font-size:12px; color:var(--muted);}
input[type="range"].vol{
-webkit-appearance:none; appearance:none;
width:140px; height:10px; border-radius:999px; background: rgba(255,255,255,.10);
outline:none; transform: rotate(-90deg); margin:54px 0;
}
input[type="range"].vol::-webkit-slider-thumb{
-webkit-appearance:none; appearance:none;
width:18px; height:18px; border-radius:50%;
background: rgba(255,255,255,.85); border:2px solid rgba(0,0,0,.35);
box-shadow:0 6px 18px rgba(0,0,0,.45); cursor:pointer;
}

.track-actions{display:flex; gap:8px; margin-top:12px; justify-content:space-between;}
.track-actions .btn{padding:9px 10px; border-radius:12px; flex:1; justify-content:center;}

.footer-note{width:min(1100px, 94vw); padding:0 10px 26px; color:var(--muted); font-size:13px; line-height:1.4;}
code{background:rgba(0,0,0,.25); padding:2px 6px; border-radius:8px; border:1px solid var(--stroke2);}
</style>
</head>
<body>

<header>
<div class="title">maracaloop A</div>
<div class="top-controls">
<div class="pill">
<span>Sorgente</span>
<select id="sourceSelect" aria-label="Sorgente audio">
<option value="mic">Microfono</option>
<option value="screen">Scheda/Schermo con audio (se supportato)</option>
</select>
</div>
<button class="btn btn-primary" id="btnInit">1) Attiva Audio</button>
<button class="btn btn-good" id="btnPlayAll" disabled>Play All</button>
<button class="btn btn-danger" id="btnStopAll" disabled>Stop All</button>
<button class="btn" id="btnClearAll" disabled>Clear All</button>
</div>
</header>

  <!-- Metronome -->
  <!-- Metronome / Grid -->
<div class="metro-wrap">
<div class="metro">
<div class="metro-left">
<div class="metro-group">
<label>Metronomo</label>
<button class="btn" id="btnMetro">ON</button>
</div>

<div class="metro-group">
<label>BPM</label>
<input id="bpm" type="range" min="60" max="120" step="1" value="90">
<div class="bpm"><span id="bpmVal">90</span></div>
</div>

<div class="metro-group">
<label>Misura</label>
<select id="tsig">
<option value="3">3/4</option>
<option value="4" selected>4/4</option>
<option value="5">5/4</option>
<option value="7">7/4</option>
</select>
</div>

<div class="metro-group">
<label>LED 1/4</label>
<div class="leds" id="beatLeds"></div>
<div class="leds" title="Downbeat">
<span class="led bar" id="barLed"></span>
</div>
</div>

<div class="metro-group">
          <label>Count-in</label>
          <label>Count-in (misure)</label>
          <select id="countInBars">
            <option value="0">0</option>
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="4" selected>4</option>
            <option value="8">8</option>
          </select>
<div class="countin" id="countInBox">—</div>
</div>
</div>

<div class="metro-right">
<div class="metro-group">
          <label>Registra (durata)</label>
          <div style="color:var(--muted); font-size:12px;">
            quantizza: +<b>2/4</b>, poi arrotonda al blocco misura
          </div>
          <label>Lunghezza REC (misure)</label>
          <select id="recBars">
            <option>1</option><option>2</option><option>4</option><option selected>8</option><option>16</option><option>32</option>
          </select>
        </div>

        <div class="metro-group">
          <label>Quantizzazione</label>
          <select id="quantMode" title="Come determinare la durata del loop registrato">
            <option value="fixed" selected>Fissa (REC bars)</option>
            <option value="ceilbars">Arrotonda su misura</option>
          </select>
          <label>Extra (1/4)</label>
          <select id="extraBeats">
            <option value="0">0</option>
            <option value="1">1</option>
            <option value="2" selected>2</option>
            <option value="3">3</option>
            <option value="4">4</option>
          </select>
        </div>

        <div class="metro-group">
          <label>Sync start</label>
          <select id="syncMode" title="Allinea start/loop alla griglia metronomo">
            <option value="on" selected>ON</option>
            <option value="off">OFF</option>
          </select>
          <span style="color:var(--muted); font-size:12px;">(play/loop precisi)</span>
</div>
</div>
</div>
</div>

<div class="statusbar">
<div class="badge"><span class="dot" id="dotAudio"></span> AudioContext</div>
<div class="badge"><span class="dot" id="dotInput"></span> Ingresso</div>
    <div class="badge">Master loop: <b id="masterLen">—</b></div>
    <div class="badge">Master: <b id="masterBars">—</b> misure • <b id="masterLen">—</b></div>
<div class="badge">SampleRate: <b id="sr">—</b></div>
<div class="badge">Codec REC: <b id="codec">—</b></div>
</div>

<main id="grid"></main>

<div class="footer-note">
<ul>
<li>Apri da <code>https://</code> o <code>http://localhost</code>. Evita <code>file://</code>.</li>
      <li>Traccia 1 (prima registrazione): tap → <b>count-in 4 MISURE</b> (BAR 0…3) → REC automatico.</li>
      <li>Tap durante il count-in: annulla.</li>
      <li>Tap breve: REC → (tap) STOP+PLAY → STOP → PLAY…</li>
      <li>Pressione lunga (>3s): conferma cancellazione traccia.</li>
      <li>Tap su una traccia vuota: avvia count-in (se impostato) → registra automaticamente per la durata scelta.</li>
      <li>Fine registrazione: la traccia va in PLAY automaticamente. Tap: STOP/PLAY. Pressione lunga (&gt;3s): clear.</li>
      <li>La prima traccia imposta la lunghezza master (misure). Le successive vengono forzate a quella durata.</li>
</ul>
</div>

<script>
(() => {
const TRACKS = 8;

// Audio
let audioCtx = null;
let inputStream = null;
let masterGain = null;

  // Master loop duration (seconds)
  // Master loop
let masterLoopSeconds = null;
  let masterBars = null;

  // Grid transport
  let gridStartTime = null; // AudioContext time of BAR 0 BEAT 0
  let transportArmed = false;

  // Metronome state (visual, mute)
  // Metronome (visual, mute)
let metroOn = false;
let metroTimer = null;
let metroBeatIndex = 0;
let nextBeatAtMs = 0;

  // Count-in: 4 MISURE (bars) starting from 0
  // Count-in state
let countInActive = false;
let countInTimer = null;
let countInBeatGlobal = 0;
  const countInBars = 4;
let countInTrackRef = null;

  // Scheduled record timer
  let recordStartTimeout = null;
  let recordStopTimeout = null;

const grid = document.getElementById("grid");
const btnInit = document.getElementById("btnInit");
const btnPlayAll = document.getElementById("btnPlayAll");
const btnStopAll = document.getElementById("btnStopAll");
const btnClearAll = document.getElementById("btnClearAll");
const sourceSelect = document.getElementById("sourceSelect");

const dotAudio = document.getElementById("dotAudio");
const dotInput = document.getElementById("dotInput");
const masterLenEl = document.getElementById("masterLen");
  const masterBarsEl = document.getElementById("masterBars");
const srEl = document.getElementById("sr");
const codecEl = document.getElementById("codec");

  // Metronome UI
  // Metronome / grid UI
const btnMetro = document.getElementById("btnMetro");
const bpm = document.getElementById("bpm");
const bpmVal = document.getElementById("bpmVal");
const tsig = document.getElementById("tsig");
const beatLeds = document.getElementById("beatLeds");
const barLed = document.getElementById("barLed");
const countInBox = document.getElementById("countInBox");

  const countInBarsSel = document.getElementById("countInBars");
  const recBarsSel = document.getElementById("recBars");
  const quantModeSel = document.getElementById("quantMode");
  const extraBeatsSel = document.getElementById("extraBeats");
  const syncModeSel = document.getElementById("syncMode");

const tracks = [];

function fmtSec(s){
if (s == null || !isFinite(s)) return "—";
return (s < 10 ? s.toFixed(2) : s.toFixed(1)) + "s";
}

function setDots(){
dotAudio.classList.toggle("on", !!audioCtx && audioCtx.state === "running");
dotInput.classList.toggle("on", !!inputStream);
}

  function setMasterLoop(seconds){
  function setMasterLoop(seconds, bars){
masterLoopSeconds = seconds;
    masterBars = bars;
masterLenEl.textContent = fmtSec(masterLoopSeconds);
    masterBarsEl.textContent = String(masterBars ?? "—");
}

function updateGlobalButtons(){
const anyHasBuffer = tracks.some(t => !!t.buffer);
const anyPlaying = tracks.some(t => t.isPlaying);
    const anyRecording = tracks.some(t => t.isRecording);
    const anyRecording = tracks.some(t => t.isRecording || t.isArmedRecord);

btnPlayAll.disabled = !audioCtx || !anyHasBuffer;
btnStopAll.disabled = !audioCtx || (!anyPlaying && !anyRecording && !countInActive);
btnClearAll.disabled = !audioCtx || !anyHasBuffer;
}

function pickBestMimeType(){
const candidates = [
'audio/webm;codecs=opus',
'audio/webm',
'audio/mp4',
'audio/ogg;codecs=opus',
'audio/ogg'
];
for (const c of candidates){
if (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(c)) return c;
}
return '';
}

  // Timing
function getBpm(){ return parseInt(bpm.value, 10); }
function getNumerator(){ return parseInt(tsig.value, 10); }
function beatSeconds(){ return 60 / getBpm(); }                 // quarter note
function barSeconds(){ return getNumerator() * beatSeconds(); } // N/4
  function getCountInBars(){ return parseInt(countInBarsSel.value, 10); }
  function getRecBars(){ return parseInt(recBarsSel.value, 10); }
  function getExtraBeats(){ return parseInt(extraBeatsSel.value, 10); }
  function getQuantMode(){ return quantModeSel.value; } // fixed or ceilbars
  function syncOn(){ return syncModeSel.value === "on"; }

  // Quantization: determine target length for a recording
  function computeTargetLengthSeconds(rawSeconds){
    const extra = getExtraBeats() * beatSeconds();
    const mode = getQuantMode();

    if (mode === "fixed"){
      // fixed bars (global rec bars) + extra beats
      const bars = (masterBars != null) ? masterBars : getRecBars();
      return bars * barSeconds() + extra;
    }

  // +2/4 extra = 2 beats (quarters) before rounding to next bar block
  function quantizeDurationSeconds(rawSeconds){
    const extra = 2 * beatSeconds();
    // ceil to next full bar after (raw + extra)
const target = rawSeconds + extra;
const bar = barSeconds();
const bars = Math.max(1, Math.ceil(target / bar));
    // If master exists, force to master length (strong sync)
    if (masterLoopSeconds != null) return masterLoopSeconds;
return bars * bar;
}

  // Transport alignment: define a gridStartTime and schedule to next bar boundary
  function ensureGridStartArmed(){
    if (!audioCtx) return;
    if (gridStartTime != null) return;

    // Put BAR0 slightly in the future so we can schedule start precisely
    const now = audioCtx.currentTime;
    const lead = 0.35; // seconds
    gridStartTime = now + lead;
    transportArmed = true;
  }

  function nextBarTime(fromTime){
    if (!syncOn() || gridStartTime == null) return fromTime;

    const bar = barSeconds();
    const t = Math.max(fromTime, audioCtx.currentTime);
    const rel = t - gridStartTime;
    const barsPassed = Math.ceil(rel / bar);
    return gridStartTime + barsPassed * bar;
  }

  function nextBeatTime(fromTime){
    if (!syncOn() || gridStartTime == null) return fromTime;

    const beat = beatSeconds();
    const t = Math.max(fromTime, audioCtx.currentTime);
    const rel = t - gridStartTime;
    const beatsPassed = Math.ceil(rel / beat);
    return gridStartTime + beatsPassed * beat;
  }

  // LEDs
function buildBeatLeds(){
beatLeds.innerHTML = "";
const n = getNumerator();
for (let i = 0; i < n; i++){
const s = document.createElement("span");
s.className = "led";
beatLeds.appendChild(s);
}
metroBeatIndex = 0;
}

function flashBeat(i){
const leds = beatLeds.querySelectorAll(".led");
leds.forEach((l, idx) => l.classList.toggle("on", idx === i));
if (i === 0){
barLed.classList.add("on");
setTimeout(() => barLed.classList.remove("on"), 110);
}
setTimeout(() => {
const l = leds[i];
if (l) l.classList.remove("on");
}, 90);
}

function stopMetronome(){
metroOn = false;
btnMetro.textContent = "ON";
if (metroTimer) clearTimeout(metroTimer);
metroTimer = null;
beatLeds.querySelectorAll(".led").forEach(l => l.classList.remove("on"));
barLed.classList.remove("on");
}

function startMetronome(){
metroOn = true;
btnMetro.textContent = "OFF";
metroBeatIndex = 0;
nextBeatAtMs = performance.now();

const tick = () => {
if (!metroOn) return;
const now = performance.now();
if (now >= nextBeatAtMs - 1){
flashBeat(metroBeatIndex);
metroBeatIndex = (metroBeatIndex + 1) % getNumerator();
nextBeatAtMs += beatSeconds() * 1000;
}
metroTimer = setTimeout(tick, 10);
};

tick();
}

  // COUNT-IN UI
  // Count-in UI
function setCountInUI(active, txt){
countInBox.textContent = txt ?? "—";
countInBox.classList.toggle("active", !!active);
}

  function clearScheduledRecordTimers(){
    if (recordStartTimeout) { clearTimeout(recordStartTimeout); recordStartTimeout = null; }
    if (recordStopTimeout) { clearTimeout(recordStopTimeout); recordStopTimeout = null; }
  }

function cancelCountIn(){
if (!countInActive) return;
countInActive = false;
if (countInTimer) clearTimeout(countInTimer);
countInTimer = null;

const t = countInTrackRef;
countInTrackRef = null;

setCountInUI(false, "—");
if (t){
t.isCountingIn = false;
      t.isArmedRecord = false;
updateTrackUI(t);
}
updateGlobalButtons();
}

  // 4 MISURE starting from BAR 0 BEAT 0
  function startCountInThenRecord(track){
    if (countInActive) cancelCountIn();

    countInActive = true;
    countInTrackRef = track;
    countInBeatGlobal = 0;

    track.isCountingIn = true;
    updateTrackUI(track);
    updateGlobalButtons();

    const wasMetroOn = metroOn;
    if (!metroOn) startMetronome();

    const beatMs = beatSeconds() * 1000;
    const beatsPerBar = getNumerator();
    const totalBeats = countInBars * beatsPerBar;

    const step = () => {
      if (!countInActive) return;

      const barIdx = Math.floor(countInBeatGlobal / beatsPerBar); // 0..3
      const beatInBar = countInBeatGlobal % beatsPerBar;          // 0..N-1

      setCountInUI(true, `COUNT BAR ${barIdx} BEAT ${beatInBar}`);
      flashBeat(beatInBar);

      countInBeatGlobal++;

      if (countInBeatGlobal >= totalBeats){
        setCountInUI(false, "—");
        countInActive = false;

        track.isCountingIn = false;
        updateTrackUI(track);
        updateGlobalButtons();

        if (!wasMetroOn) stopMetronome();

        startRecording(track);
        return;
      }

      countInTimer = setTimeout(step, beatMs);
    };

    step();
  function stopAllInput(){
    if (inputStream){
      for (const tr of inputStream.getTracks()) tr.stop();
      inputStream = null;
    }
}

// Input
async function getInputStream(){
const mode = sourceSelect.value;
if (mode === "mic"){
return await navigator.mediaDevices.getUserMedia({
audio: { echoCancellation:false, noiseSuppression:false, autoGainControl:false },
video: false
});
}
return await navigator.mediaDevices.getDisplayMedia({ audio:true, video:true });
}

  function stopAllInput(){
    if (inputStream){
      for (const tr of inputStream.getTracks()) tr.stop();
      inputStream = null;
    }
  }

  // Tracks
function createTrack(index){
return {
index,
buffer: null,
source: null,
gainNode: null,

recorder: null,
recChunks: [],
isRecording: false,
isPlaying: false,
isCountingIn: false,
      isArmedRecord: false,

loopCount: 0,
loopTimer: null,

longPressTimer: null,
longPressFired: false,

ui: {}
};
}

function stopLoopCounter(t){
if (t.loopTimer){
clearInterval(t.loopTimer);
t.loopTimer = null;
}
t.loopCount = 0;
}

function startLoopCounter(t){
stopLoopCounter(t);
t.loopCount = 0;
const dur = t.buffer?.duration;
if (!dur || !isFinite(dur) || dur <= 0.01) return;

t.loopTimer = setInterval(() => {
if (!t.isPlaying) return;
t.loopCount++;
updateTrackUI(t);
}, Math.max(50, dur * 1000));
}

function stopPlayback(t){
if (t.source){
try { t.source.stop(); } catch {}
try { t.source.disconnect(); } catch {}
t.source = null;
}
t.isPlaying = false;
stopLoopCounter(t);
updateTrackUI(t);
updateGlobalButtons();
}

  // Start playback aligned to grid start (next bar) if sync ON
function startPlayback(t){
if (!audioCtx || !t.buffer) return;

stopPlayback(t);

const src = audioCtx.createBufferSource();
src.buffer = t.buffer;
src.loop = true;
src.loopStart = 0;
src.loopEnd = t.buffer.duration;
src.connect(t.gainNode);
    src.start();

    let startAt = audioCtx.currentTime + 0.02;
    if (syncOn()){
      ensureGridStartArmed();
      startAt = nextBarTime(audioCtx.currentTime + 0.05);
    }
    try { src.start(startAt); } catch { src.start(); }

t.source = src;
t.isPlaying = true;
startLoopCounter(t);

updateTrackUI(t);
updateGlobalButtons();
}

function clearTrack(t){
if (t.isCountingIn) cancelCountIn();
    if (t.isArmedRecord) { t.isArmedRecord = false; clearScheduledRecordTimers(); }
if (t.isRecording) stopRecording(t, { autoPlay:false });
stopPlayback(t);
t.buffer = null;
updateTrackUI(t);
updateGlobalButtons();
}

function quantizeToFixedSeconds(buf, seconds){
const sr = buf.sampleRate;
const targetFrames = Math.max(1, Math.round(seconds * sr));
const chs = buf.numberOfChannels;
const out = audioCtx.createBuffer(chs, targetFrames, sr);

for (let ch=0; ch<chs; ch++){
const inData = buf.getChannelData(ch);
const outData = out.getChannelData(ch);
if (inData.length >= targetFrames){
outData.set(inData.subarray(0, targetFrames));
} else {
outData.set(inData);
}
}
return out;
}

async function blobToAudioBuffer(blob){
const arrayBuf = await blob.arrayBuffer();
return await audioCtx.decodeAudioData(arrayBuf);
}

function mixToMonoIfNeeded(decoded){
if (decoded.numberOfChannels <= 1) return decoded;
const mono = audioCtx.createBuffer(1, decoded.length, decoded.sampleRate);
const out = mono.getChannelData(0);
for (let ch=0; ch<decoded.numberOfChannels; ch++){
const d = decoded.getChannelData(ch);
for (let i=0; i<d.length; i++) out[i] += d[i] / decoded.numberOfChannels;
}
return mono;
}

  function startRecording(t){
  function startRecordingNow(t){
if (!audioCtx || !inputStream) return;
if (!window.MediaRecorder) return alert("MediaRecorder non disponibile in questo browser.");
if (t.isRecording) return;

stopPlayback(t);

t.recChunks = [];
const mime = pickBestMimeType();
codecEl.textContent = mime || "(auto)";

let rec;
try {
rec = new MediaRecorder(inputStream, mime ? { mimeType: mime } : undefined);
} catch {
rec = new MediaRecorder(inputStream);
codecEl.textContent = "(fallback)";
}

t.recorder = rec;
t.isRecording = true;
    t.isArmedRecord = false;

rec.ondataavailable = (ev) => {
if (ev.data && ev.data.size > 0) t.recChunks.push(ev.data);
};

rec.onerror = (ev) => {
console.error("Recorder error", ev);
alert("Errore registrazione: " + (ev?.error?.message || ev?.message || ev));
t.isRecording = false;
t.recorder = null;
t.recChunks = [];
updateTrackUI(t);
updateGlobalButtons();
};

rec.start(250);
updateTrackUI(t);
updateGlobalButtons();
}

function stopRecording(t, { autoPlay } = { autoPlay: true }){
if (!t.recorder || !t.isRecording) return;

const rec = t.recorder;

rec.onstop = async () => {
try{
const blob = new Blob(t.recChunks, { type: rec.mimeType || 'audio/webm' });
if (blob.size < 2000){
t.buffer = null;
return;
}

const decoded = await blobToAudioBuffer(blob);
const mono = mixToMonoIfNeeded(decoded);

        const qLen = quantizeDurationSeconds(mono.duration);
        let buf = quantizeToFixedSeconds(mono, qLen);
        // Decide target length
        let targetLen = computeTargetLengthSeconds(mono.duration);

        // If master exists, force exact master length (tight sync)
        if (masterLoopSeconds != null) targetLen = masterLoopSeconds;

        let buf = quantizeToFixedSeconds(mono, targetLen);

        // If no master, set master from current settings (bars)
if (masterLoopSeconds == null){
          setMasterLoop(qLen);
        } else {
          buf = quantizeToFixedSeconds(buf, masterLoopSeconds);
          const bars = getRecBars();
          // In fixed mode, master bars is recBars; in ceil mode, infer from seconds
          const inferredBars = Math.max(1, Math.round(targetLen / barSeconds()));
          const masterBarsChosen = (getQuantMode() === "fixed") ? bars : inferredBars;
          setMasterLoop(targetLen, masterBarsChosen);
}

t.buffer = buf;

        // Auto-play aligned to grid
if (autoPlay) startPlayback(t);
} catch (e){
console.error(e);
alert("Errore decodifica audio: " + (e?.message || e));
} finally {
t.isRecording = false;
t.recorder = null;
t.recChunks = [];
updateTrackUI(t);
updateGlobalButtons();
}
};

try { rec.stop(); } catch {}
updateTrackUI(t);
updateGlobalButtons();
}

  // Schedule recording: align to next bar, record for master bars (or recBars if no master)
  function armRecordWithGrid(t){
    if (!audioCtx) return;

    // Determine record bars: if master exists, lock to master
    const bars = (masterBars != null) ? masterBars : getRecBars();
    const recLen = bars * barSeconds();

    // Ensure transport start
    if (syncOn()) ensureGridStartArmed();

    // Compute start time (next bar)
    const startAt = syncOn() ? nextBarTime(audioCtx.currentTime + 0.05) : (audioCtx.currentTime + 0.05);
    const stopAt = startAt + recLen;

    // Mark armed
    t.isArmedRecord = true;
    updateTrackUI(t);
    updateGlobalButtons();

    // Use setTimeout to start/stop MediaRecorder close to desired times
    // Note: MediaRecorder isn't sample-accurate; we compensate by forcing buffer to exact loop length.
    const now = audioCtx.currentTime;
    const startDelayMs = Math.max(0, (startAt - now) * 1000);
    const stopDelayMs  = Math.max(0, (stopAt  - now) * 1000);

    clearScheduledRecordTimers();

    recordStartTimeout = setTimeout(() => {
      startRecordingNow(t);
    }, startDelayMs);

    recordStopTimeout = setTimeout(() => {
      stopRecording(t, { autoPlay:true });
    }, stopDelayMs);

    // UI helper
    setCountInUI(true, `REC ARMED • start fra ${(startDelayMs/1000).toFixed(2)}s • durata ${bars} bars`);
  }

  // Count-in (bars) then arm record
  function startCountInThenArmRecord(t){
    if (countInActive) cancelCountIn();
    countInActive = true;
    countInTrackRef = t;
    countInBeatGlobal = 0;

    t.isCountingIn = true;
    updateTrackUI(t);
    updateGlobalButtons();

    const barsToCount = getCountInBars();
    if (barsToCount <= 0){
      // No count-in -> arm immediately
      countInActive = false;
      t.isCountingIn = false;
      setCountInUI(false, "—");
      updateTrackUI(t);
      armRecordWithGrid(t);
      return;
    }

    const wasMetroOn = metroOn;
    if (!metroOn) startMetronome();

    const beatMs = beatSeconds() * 1000;
    const beatsPerBar = getNumerator();
    const totalBeats = barsToCount * beatsPerBar;

    const step = () => {
      if (!countInActive) return;

      const barIdx = Math.floor(countInBeatGlobal / beatsPerBar);
      const beatInBar = countInBeatGlobal % beatsPerBar;

      setCountInUI(true, `COUNT BAR ${barIdx} BEAT ${beatInBar}`);
      flashBeat(beatInBar);

      countInBeatGlobal++;

      if (countInBeatGlobal >= totalBeats){
        setCountInUI(false, "—");
        countInActive = false;

        t.isCountingIn = false;
        updateTrackUI(t);
        updateGlobalButtons();

        if (!wasMetroOn) stopMetronome();

        armRecordWithGrid(t);
        return;
      }

      countInTimer = setTimeout(step, beatMs);
    };

    step();
  }

// Main tap:
  // - Track 1 first time: count-in 4 bars then REC
  // - Tap during count-in: cancel
  // - Empty: REC / stopREC+autoplay
  // - With buffer: toggle stop/play
  // - If counting-in: cancel
  // - If armed record: cancel arming (safe)
  // - If empty: start count-in/arm record
  // - If has buffer: toggle play/stop (aligned)
async function onMainTap(t){
if (!audioCtx) return alert("Prima clicca: Attiva Audio");
try { await audioCtx.resume(); } catch {}

if (t.isCountingIn){
cancelCountIn();
return;
}
    if (t.isArmedRecord){
      t.isArmedRecord = false;
      clearScheduledRecordTimers();
      setCountInUI(false, "—");
      updateTrackUI(t);
      updateGlobalButtons();
      return;
    }
if (countInActive) return;

    if (t.index === 0 && masterLoopSeconds == null && !t.buffer && !t.isRecording){
      startCountInThenRecord(t);
    if (!t.buffer && !t.isRecording){
      // First action on first track initializes grid transport
      if (syncOn()) ensureGridStartArmed();
      startCountInThenArmRecord(t);
return;
}

    if (!t.buffer){
      if (!t.isRecording) startRecording(t);
      else stopRecording(t, { autoPlay: true });
    if (t.isRecording){
      // Manual stop allowed (will still quantize to master/fixed length)
      stopRecording(t, { autoPlay:true });
return;
}

    // has buffer
if (t.isPlaying) stopPlayback(t);
else startPlayback(t);
}

function updateTrackUI(t){
const { btnMain, tag, label, dot, vol, volpct, muteBtn, clearBtn } = t.ui;

if (t.isCountingIn){
tag.textContent = "COUNT";
tag.className = "tag count";
dot.className = "dot rec";
label.textContent = "count-in…";
    } else if (t.isArmedRecord){
      tag.textContent = "ARM";
      tag.className = "tag rec";
      dot.className = "dot rec";
      label.textContent = "armed…";
} else if (t.isRecording){
tag.textContent = "REC";
tag.className = "tag rec";
dot.className = "dot rec";
label.textContent = "registrazione…";
} else if (t.isPlaying){
tag.textContent = "PLAY";
tag.className = "tag play";
dot.className = "dot play";
const lc = t.loopCount ? (" • x" + t.loopCount) : "";
label.textContent = "in loop" + lc;
} else {
tag.textContent = "STOP";
tag.className = "tag stop";
dot.className = "dot";
label.textContent = t.buffer ? ("pronto • " + fmtSec(t.buffer.duration)) : "vuoto";
}

const svg = btnMain.querySelector("svg");
const path = svg.querySelector("path");

    if (t.isCountingIn){
    if (t.isCountingIn || t.isArmedRecord){
path.setAttribute("d", "M16 10a6 6 0 1 0 0 12a6 6 0 0 0 0-12Z");
svg.style.stroke = "rgba(255,59,59,.95)";
} else if (!t.buffer){
if (t.isRecording){
path.setAttribute("d", "M9 9h14v14H9z");
svg.style.stroke = "rgba(255,59,59,.95)";
} else {
path.setAttribute("d", "M16 10a6 6 0 1 0 0 12a6 6 0 0 0 0-12Z");
svg.style.stroke = "rgba(255,59,59,.95)";
}
} else {
if (t.isPlaying){
path.setAttribute("d", "M9 9h14v14H9z");
svg.style.stroke = "rgba(78,230,255,.95)";
} else {
path.setAttribute("d", "M12 10l12 6-12 6V10z");
svg.style.stroke = "rgba(68,255,154,.95)";
}
}

    clearBtn.disabled = (!t.buffer && !t.isRecording && !t.isCountingIn);
    clearBtn.disabled = (!t.buffer && !t.isRecording && !t.isCountingIn && !t.isArmedRecord);
muteBtn.disabled = !t.gainNode;

const v = parseFloat(vol.value);
volpct.textContent = Math.round(v*100) + "%";
}

// Long press (>3s) clears track (with confirm)
function attachLongPress(t, btnMain){
const start = (ev) => {
ev.preventDefault();
t.longPressFired = false;
t.longPressTimer = setTimeout(() => {
t.longPressFired = true;
        if (!t.buffer && !t.isRecording && !t.isCountingIn) return;
        if (!t.buffer && !t.isRecording && !t.isCountingIn && !t.isArmedRecord) return;
const ok = confirm(`Cancellare traccia ${t.index+1}?`);
if (ok) clearTrack(t);
}, 3000);
};

const end = () => {
if (t.longPressTimer) clearTimeout(t.longPressTimer);
t.longPressTimer = null;
};

btnMain.addEventListener("pointerdown", start, { passive:false });
btnMain.addEventListener("pointerup", end);
btnMain.addEventListener("pointercancel", end);
btnMain.addEventListener("pointerleave", end);

btnMain.addEventListener("click", (ev) => {
if (t.longPressFired){
ev.preventDefault();
ev.stopPropagation();
t.longPressFired = false;
return;
}
onMainTap(t);
});
}

function buildTrackCard(t){
const el = document.createElement("section");
el.className = "track";
el.innerHTML = `
     <div class="track-head">
       <div class="track-title">
         <div class="n">${t.index+1}</div>
         <div class="label" id="label">vuoto</div>
       </div>
       <div class="mini">
         <span class="dot" id="dot"></span>
         <span class="tag stop" id="tag">STOP</span>
       </div>
     </div>

     <div class="track-body">
       <div style="text-align:center;">
         <div class="big-btn" id="btnMain" role="button" tabindex="0" aria-label="Record/Play (long press = clear)">
           <div class="ring"></div>
           <div class="ring2"></div>
           <div class="icon">
             <svg viewBox="0 0 32 32" stroke="rgba(255,59,59,.95)">
               <path d="M16 10a6 6 0 1 0 0 12a6 6 0 0 0 0-12Z"></path>
             </svg>
           </div>
         </div>
       </div>

       <div class="fader">
         <label>VOL</label>
         <input class="vol" id="vol" type="range" min="0" max="1" step="0.01" value="0.85" />
         <label id="volpct">85%</label>
       </div>
     </div>

     <div class="track-actions">
       <button class="btn" id="muteBtn">Mute</button>
       <button class="btn" id="clearBtn">Clear</button>
     </div>
   `;

const btnMain = el.querySelector("#btnMain");
const tag = el.querySelector("#tag");
const label = el.querySelector("#label");
const dot = el.querySelector("#dot");
const vol = el.querySelector("#vol");
const volpct = el.querySelector("#volpct");
const muteBtn = el.querySelector("#muteBtn");
const clearBtn = el.querySelector("#clearBtn");

t.ui = { el, btnMain, tag, label, dot, vol, volpct, muteBtn, clearBtn };

attachLongPress(t, btnMain);

btnMain.addEventListener("keydown", (e) => {
if (e.key === "Enter" || e.key === " ") { e.preventDefault(); btnMain.click(); }
});

vol.addEventListener("input", () => {
const v = parseFloat(vol.value);
if (t.gainNode) t.gainNode.gain.value = v;
updateTrackUI(t);
});

muteBtn.addEventListener("click", () => {
if (!t.gainNode) return;
const currently = t.gainNode.gain.value;
if (currently > 0.0001){
t._prevVol = parseFloat(vol.value);
t.gainNode.gain.value = 0;
vol.value = "0";
} else {
const pv = (t._prevVol != null) ? t._prevVol : 0.85;
t.gainNode.gain.value = pv;
vol.value = String(pv);
}
vol.dispatchEvent(new Event("input"));
});

clearBtn.addEventListener("click", () => {
const ok = confirm(`Cancellare traccia ${t.index+1}?`);
if (ok) clearTrack(t);
});

updateTrackUI(t);
return el;
}

function buildUI(){
grid.innerHTML = "";
tracks.length = 0;
for (let i=0; i<TRACKS; i++){
const t = createTrack(i);
tracks.push(t);
grid.appendChild(buildTrackCard(t));
}
updateGlobalButtons();
}

async function initAudio(){
if (audioCtx) return;

audioCtx = new (window.AudioContext || window.webkitAudioContext)();
srEl.textContent = audioCtx.sampleRate + " Hz";

masterGain = audioCtx.createGain();
masterGain.gain.value = 0.95;
masterGain.connect(audioCtx.destination);

inputStream = await getInputStream();

for (const t of tracks){
t.gainNode = audioCtx.createGain();
t.gainNode.gain.value = parseFloat(t.ui.vol.value);
t.gainNode.connect(masterGain);
}

await audioCtx.resume();
setDots();

btnInit.textContent = "Audio attivo";
btnInit.disabled = true;
updateGlobalButtons();
}

// Global controls
btnInit.addEventListener("click", async () => {
try{
await initAudio();
} catch (e){
console.error(e);
alert("Impossibile attivare audio: " + (e?.message || e));
stopAllInput();
} finally {
setDots();
updateGlobalButtons();
}
});

btnPlayAll.addEventListener("click", () => {
for (const t of tracks) if (t.buffer && !t.isPlaying) startPlayback(t);
updateGlobalButtons();
});

btnStopAll.addEventListener("click", () => {
if (countInActive) cancelCountIn();
    clearScheduledRecordTimers();
    setCountInUI(false, "—");
for (const t of tracks){
      if (t.isArmedRecord) t.isArmedRecord = false;
if (t.isRecording) stopRecording(t, { autoPlay:false });
if (t.isPlaying) stopPlayback(t);
      updateTrackUI(t);
}
updateGlobalButtons();
});

btnClearAll.addEventListener("click", () => {
if (!confirm("Cancellare tutte le tracce?")) return;
if (countInActive) cancelCountIn();
    clearScheduledRecordTimers();
    setCountInUI(false, "—");
for (const t of tracks) clearTrack(t);
masterLoopSeconds = null;
    masterBars = null;
    gridStartTime = null;
    transportArmed = false;
masterLenEl.textContent = "—";
    masterBarsEl.textContent = "—";
updateGlobalButtons();
});

sourceSelect.addEventListener("change", () => {
if (audioCtx){
alert("Hai cambiato sorgente. Ricarica la pagina per applicarla.");
}
});

// Metronome controls
btnMetro.addEventListener("click", () => {
if (metroOn) stopMetronome();
else startMetronome();
});

  bpm.addEventListener("input", () => {
  function onTimingChange(){
bpmVal.textContent = bpm.value;

    // If count-in active, restart it from BAR 0 with new BPM (stable)
    if (countInActive){
      const t = countInTrackRef;
      cancelCountIn();
      if (t && t.index === 0 && masterLoopSeconds == null && !t.buffer && !t.isRecording){
        startCountInThenRecord(t);
      }
    }
    // Count-in stability: cancel (user can restart)
    if (countInActive) cancelCountIn();
    clearScheduledRecordTimers();
    setCountInUI(false, "—");

    // Restart metronome for clean LED tempo
if (metroOn){
stopMetronome();
startMetronome();
}
  });

  tsig.addEventListener("change", () => {
    buildBeatLeds();
    if (metroOn){
      stopMetronome();
      startMetronome();
    // If master already exists, changing BPM or time signature changes the meaning of "bars".
    // Keep audio master length as-is (seconds), but update displayed master bars as "locked".
    if (masterLoopSeconds != null){
      // show lock message in countInBox briefly
      setCountInUI(true, "MASTER locked (durata in secondi) • clear all per resettare");
      setTimeout(() => setCountInUI(false, "—"), 1400);
}

    // Rebuild LEDs when time signature changes
    buildBeatLeds();
  }

  bpm.addEventListener("input", onTimingChange);
  tsig.addEventListener("change", onTimingChange);

  // Param changes: just cancel count-in / arming for safety
  [countInBarsSel, recBarsSel, quantModeSel, extraBeatsSel, syncModeSel].forEach(el => {
    el.addEventListener("change", () => {
      if (countInActive) cancelCountIn();
      clearScheduledRecordTimers();
      setCountInUI(false, "—");
      for (const t of tracks){
        if (t.isArmedRecord){
          t.isArmedRecord = false;
          updateTrackUI(t);
        }
      }
      updateGlobalButtons();
    });
});

// Init UI
buildUI();
buildBeatLeds();
bpmVal.textContent = bpm.value;
  masterLenEl.textContent = "—";
  masterBarsEl.textContent = "—";
setCountInUI(false, "—");
  srEl.textContent = "—";

setInterval(() => setDots(), 500);
})();
</script>
</body>
</html>
