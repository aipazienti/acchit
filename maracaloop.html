<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Maracaloop A ‚Äî 8 Tracce</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=DM+Sans:wght@300;400;600&display=swap');

    :root{
      --bg:#080b10;
      --panel:#0e1420;
      --text:#e8eeff;
      --muted:#6a7899;
      --red:#ff3a3a;
      --green:#2dff8f;
      --cyan:#00d4ff;
      --stroke:#1e2840;
      --stroke2:#151c2e;
      --r: 16px;
    }
    *{box-sizing:border-box;margin:0;padding:0}
    body{
      font-family:'DM Sans', sans-serif;
      background: var(--bg);
      background-image:
        radial-gradient(ellipse 800px 400px at 20% 10%, rgba(0,100,255,.07) 0%, transparent 70%),
        radial-gradient(ellipse 600px 400px at 80% 60%, rgba(0,220,100,.05) 0%, transparent 70%);
      color:var(--text);
      min-height:100vh;
    }

    header{
      max-width:1120px;
      margin:0 auto;
      padding:22px 20px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
      gap:14px;
      border-bottom:1px solid var(--stroke);
    }
    .logo{
      font-family:'Space Mono', monospace;
      font-size:20px;
      font-weight:700;
      letter-spacing:.15em;
    }
    .logo span{ color: var(--cyan); }

    .top-controls{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }

    select{
      font: inherit;
      background: var(--panel);
      border:1px solid var(--stroke);
      color:var(--text);
      padding:9px 12px;
      border-radius:10px;
      outline:none;
      cursor:pointer;
    }
    select:focus{ border-color: rgba(0,212,255,.4); }

    button{
      font: inherit;
      cursor:pointer;
      border:1px solid var(--stroke);
      background: var(--panel);
      color:var(--text);
      padding:9px 16px;
      border-radius:10px;
      transition: background .15s, border-color .15s, transform .06s;
      display:inline-flex;
      align-items:center;
      gap:7px;
    }
    button:active{ transform: translateY(1px); }
    button:hover{ background: rgba(255,255,255,.06); }
    button:disabled{ opacity:.35; cursor:not-allowed; pointer-events:none; }
    .btn-init{ border-color: rgba(0,212,255,.4); color: var(--cyan); }
    .btn-play{ border-color: rgba(45,255,143,.4); color: var(--green); }
    .btn-stop{ border-color: rgba(255,58,58,.3); color: #ff8080; }
    .btn-clear{ border-color: var(--stroke2); }

    .statusbar{
      max-width:1120px;
      margin:0 auto;
      padding:12px 20px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .badge{
      font-family:'Space Mono', monospace;
      font-size:11px;
      padding:5px 10px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.3);
      border-radius:999px;
      display:inline-flex;
      align-items:center;
      gap:7px;
      color: var(--muted);
    }
    .dot{
      width:8px; height:8px;
      border-radius:50%;
      background:#333;
      flex-shrink:0;
    }
    .dot.on{ background: var(--green); box-shadow: 0 0 6px var(--green); }
    .dot.rec{ background: var(--red); box-shadow: 0 0 6px var(--red); }
    .dot.play{ background: var(--cyan); box-shadow: 0 0 6px var(--cyan); }

    main{
      max-width:1120px;
      margin:0 auto;
      padding:20px;
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap:14px;
    }
    @media(max-width:980px){ main{ grid-template-columns: repeat(2, 1fr); } }
    @media(max-width:520px){ main{ grid-template-columns: 1fr; } }

    .track{
      background: var(--panel);
      border:1px solid var(--stroke);
      border-radius: var(--r);
      padding:14px;
      position:relative;
      overflow:hidden;
      transition: border-color .2s;
    }
    .track.is-rec{ border-color: rgba(255,58,58,.5); }
    .track.is-play{ border-color: rgba(0,212,255,.4); }
    .track.has-buffer{ border-color: rgba(45,255,143,.25); }

    .track-glow{
      position:absolute;
      inset:0;
      pointer-events:none;
      opacity:0;
      transition: opacity .3s;
      background: radial-gradient(circle at 50% 0%, rgba(255,58,58,.08), transparent 60%);
    }
    .track.is-rec .track-glow{ opacity:1; }
    .track.is-play .track-glow{
      background: radial-gradient(circle at 50% 0%, rgba(0,212,255,.07), transparent 60%);
      opacity:1;
    }

    .track > *:not(.track-glow){ position:relative; }

    .track-head{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      margin-bottom:12px;
    }
    .track-num{
      font-family:'Space Mono', monospace;
      font-size:26px;
      font-weight:700;
      color: rgba(255,255,255,.12);
      line-height:1;
    }
    .track-state{
      font-size:11px;
      font-family:'Space Mono', monospace;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid var(--stroke2);
      color: var(--muted);
      background: rgba(0,0,0,.3);
      letter-spacing:.05em;
    }
    .track-state.s-rec{ border-color: rgba(255,58,58,.5); color: #ff8080; }
    .track-state.s-play{ border-color: rgba(0,212,255,.4); color: var(--cyan); }
    .track-state.s-ready{ border-color: rgba(45,255,143,.3); color: var(--green); }

    /* BIG BUTTON */
    .btn-main-wrap{
      display:flex;
      justify-content:center;
      margin: 8px 0 12px;
    }
    .btn-main{
      width:100px; height:100px;
      border-radius:50%;
      border:2px solid var(--stroke);
      background: rgba(0,0,0,.35);
      position:relative;
      cursor:pointer;
      transition: border-color .2s, transform .1s;
      display:grid;
      place-items:center;
    }
    .btn-main:hover{ transform: scale(1.04); }
    .btn-main:active{ transform: scale(.97); }

    /* spinning ring */
    .btn-main .spin-ring{
      position:absolute;
      inset:-6px;
      border-radius:50%;
      border:3px solid transparent;
      border-top-color: var(--red);
      border-right-color: rgba(255,58,58,.3);
      animation: none;
      opacity:0;
      transition: opacity .2s;
    }
    .track.is-rec .btn-main .spin-ring{
      opacity:1;
      animation: spin 1.2s linear infinite;
    }
    .track.is-play .btn-main .spin-ring{
      border-top-color: var(--cyan);
      border-right-color: rgba(0,212,255,.3);
      animation: spin 2s linear infinite;
      opacity:1;
    }
    @keyframes spin{ to{ transform: rotate(360deg); } }

    .btn-main svg{
      width:34px; height:34px;
    }

    .track-info{
      font-size:12px;
      color: var(--muted);
      text-align:center;
      min-height:16px;
      margin-bottom:12px;
      font-family:'Space Mono', monospace;
    }

    /* volume */
    .vol-row{
      display:flex;
      align-items:center;
      gap:8px;
      margin-bottom:10px;
    }
    .vol-label{
      font-size:10px;
      font-family:'Space Mono', monospace;
      color: var(--muted);
      min-width:28px;
    }
    input[type="range"]{
      -webkit-appearance:none;
      appearance:none;
      flex:1;
      height:4px;
      border-radius:999px;
      background: rgba(255,255,255,.08);
      outline:none;
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none;
      width:14px; height:14px;
      border-radius:50%;
      background: rgba(255,255,255,.8);
      border:1px solid rgba(0,0,0,.4);
      cursor:pointer;
    }
    .vol-pct{
      font-size:10px;
      font-family:'Space Mono', monospace;
      color: var(--muted);
      min-width:32px;
      text-align:right;
    }

    .track-btns{
      display:flex;
      gap:6px;
    }
    .track-btns button{
      flex:1;
      padding:8px 6px;
      font-size:12px;
      justify-content:center;
      border-radius:10px;
    }
    .btn-mute{ }
    .btn-muted{ color: #ff8080; border-color: rgba(255,58,58,.35); }
    .btn-clear-t{ border-color: var(--stroke2); }

    /* waveform canvas */
    .waveform{
      width:100%;
      height:36px;
      display:block;
      border-radius:8px;
      background: rgba(0,0,0,.2);
      margin-bottom:10px;
      opacity:.7;
    }

    footer{
      max-width:1120px;
      margin:0 auto;
      padding:14px 20px 30px;
      font-size:12px;
      color: var(--muted);
      line-height:1.7;
      border-top:1px solid var(--stroke);
    }
    footer code{
      background: rgba(0,0,0,.35);
      padding:2px 6px;
      border-radius:6px;
      font-family:'Space Mono', monospace;
    }
    .error-toast{
      position:fixed;
      bottom:20px;
      left:50%;
      transform:translateX(-50%);
      background: rgba(255,58,58,.15);
      border:1px solid rgba(255,58,58,.4);
      color: #ffaaaa;
      padding:12px 22px;
      border-radius:12px;
      font-size:14px;
      z-index:999;
      max-width:90vw;
      text-align:center;
      display:none;
    }
  </style>
</head>
<body>

<div class="error-toast" id="toast"></div>

<header>
  <div class="logo">MARACA<span>LOOP</span></div>
  <div class="top-controls">
    <select id="sourceSelect" aria-label="Sorgente audio">
      <option value="mic">üéô Microfono</option>
      <option value="screen">üñ• Schermo / Tab con audio</option>
    </select>
    <button class="btn-init" id="btnInit">‚ö° Attiva Audio</button>
    <button class="btn-play" id="btnPlayAll" disabled>‚ñ∂ Play All</button>
    <button class="btn-stop" id="btnStopAll" disabled>‚ñ† Stop All</button>
    <button class="btn-clear" id="btnClearAll" disabled>‚úï Clear All</button>
  </div>
</header>

<div class="statusbar">
  <span class="badge"><span class="dot" id="dotAudio"></span> AudioContext</span>
  <span class="badge"><span class="dot" id="dotInput"></span> Ingresso</span>
  <span class="badge">Loop master: <b id="masterLen">‚Äî</b></span>
  <span class="badge">SR: <b id="sr">‚Äî</b></span>
</div>

<main id="grid"></main>

<footer>
  ‚ö† Usa <code>https://</code> o <code>localhost</code> per accedere al microfono. &nbsp;|&nbsp;
  La <b>prima traccia registrata</b> definisce la durata del loop. Le altre vengono adattate. &nbsp;|&nbsp;
  Per catturare audio da una scheda: scegli <i>Schermo/Tab</i> e condividi la scheda con audio abilitato.
</footer>

<script>
// ==========================================
// CORE AUDIO (usa MediaRecorder invece di AudioWorklet per affidabilit√†)
// ==========================================

let audioCtx = null;
let inputStream = null;
let inputNode = null;
let masterGain = null;
let isInitialized = false;
let masterLoopSeconds = null;

const TRACKS = 8;
const tracks = [];

// UI refs
const grid = document.getElementById("grid");
const btnInit = document.getElementById("btnInit");
const btnPlayAll = document.getElementById("btnPlayAll");
const btnStopAll = document.getElementById("btnStopAll");
const btnClearAll = document.getElementById("btnClearAll");
const sourceSelect = document.getElementById("sourceSelect");
const dotAudio = document.getElementById("dotAudio");
const dotInput = document.getElementById("dotInput");
const masterLenEl = document.getElementById("masterLen");
const srEl = document.getElementById("sr");
const toast = document.getElementById("toast");

function showToast(msg, dur=4000){
  toast.textContent = msg;
  toast.style.display = "block";
  clearTimeout(toast._t);
  toast._t = setTimeout(()=>{ toast.style.display="none"; }, dur);
}

function fmtSec(s){
  if(s==null||!isFinite(s)) return "‚Äî";
  return s<10 ? s.toFixed(2)+"s" : s.toFixed(1)+"s";
}

function setDots(){
  dotAudio.className = "dot" + (audioCtx && audioCtx.state==="running" ? " on" : "");
  dotInput.className = "dot" + (inputStream ? " on" : "");
}

function setMasterLoop(sec){
  masterLoopSeconds = sec;
  masterLenEl.textContent = fmtSec(masterLoopSeconds);
}

function updateGlobalButtons(){
  const anyBuf = tracks.some(t=>!!t.buffer);
  const anyPlay = tracks.some(t=>t.isPlaying);
  btnPlayAll.disabled = !isInitialized || !anyBuf;
  btnStopAll.disabled = !isInitialized || !anyPlay;
  btnClearAll.disabled = !isInitialized || !anyBuf;
}

// ==========================================
// DECODING: Blob (da MediaRecorder) ‚Üí AudioBuffer
// ==========================================
async function blobToAudioBuffer(blob){
  const ab = await blob.arrayBuffer();
  return await audioCtx.decodeAudioData(ab);
}

// ==========================================
// Quantize to master loop length
// ==========================================
function quantizeBuffer(buf){
  if(masterLoopSeconds==null) return buf;
  const sr = buf.sampleRate;
  const target = Math.round(masterLoopSeconds * sr);
  const chs = buf.numberOfChannels;
  const out = audioCtx.createBuffer(chs, target, sr);
  for(let c=0; c<chs; c++){
    const inp = buf.getChannelData(c);
    const outp = out.getChannelData(c);
    if(inp.length >= target){
      outp.set(inp.subarray(0, target));
    } else {
      outp.set(inp); // pad with zeros
    }
  }
  return out;
}

// ==========================================
// Draw waveform on canvas
// ==========================================
function drawWaveform(canvas, audioBuffer){
  const ctx = canvas.getContext("2d");
  const W = canvas.width = canvas.offsetWidth * devicePixelRatio;
  const H = canvas.height = canvas.offsetHeight * devicePixelRatio;
  ctx.clearRect(0,0,W,H);

  if(!audioBuffer){ return; }

  const data = audioBuffer.getChannelData(0);
  const step = Math.ceil(data.length / W);
  const mid = H/2;

  ctx.strokeStyle = "rgba(0,212,255,.7)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  for(let x=0; x<W; x++){
    let min=1, max=-1;
    for(let j=0; j<step; j++){
      const v = data[x*step+j] || 0;
      if(v<min) min=v;
      if(v>max) max=v;
    }
    ctx.moveTo(x, mid + min*mid*0.9);
    ctx.lineTo(x, mid + max*mid*0.9);
  }
  ctx.stroke();
}

// ==========================================
// TRACK
// ==========================================
function createTrack(index){
  return {
    index,
    buffer: null,
    source: null,
    gainNode: null,
    mediaRec: null,         // MediaRecorder
    recChunks: [],
    isRecording: false,
    isPlaying: false,
    isMuted: false,
    _prevVol: 0.85,
    ui: {}
  };
}

function stopPlayback(t){
  if(t.source){
    try{ t.source.stop(); }catch{}
    try{ t.source.disconnect(); }catch{}
    t.source = null;
  }
  t.isPlaying = false;
  updateTrackUI(t);
  updateGlobalButtons();
}

function startPlayback(t){
  if(!t.buffer || !audioCtx) return;
  stopPlayback(t);
  const src = audioCtx.createBufferSource();
  src.buffer = t.buffer;
  src.loop = true;
  src.loopStart = 0;
  src.loopEnd = t.buffer.duration;
  src.connect(t.gainNode);
  src.start();
  src.onended = () => {
    if(t.source === src){ t.isPlaying = false; updateTrackUI(t); updateGlobalButtons(); }
  };
  t.source = src;
  t.isPlaying = true;
  updateTrackUI(t);
  updateGlobalButtons();
}

function clearTrack(t){
  stopPlayback(t);
  if(t.isRecording) abortRecording(t);
  t.buffer = null;
  drawWaveform(t.ui.canvas, null);
  updateTrackUI(t);
  updateGlobalButtons();
}

function abortRecording(t){
  if(t.mediaRec && t.isRecording){
    t.mediaRec.ondataavailable = null;
    t.mediaRec.onstop = null;
    try{ t.mediaRec.stop(); }catch{}
  }
  t.isRecording = false;
  t.recChunks = [];
}

// ==========================================
// MediaRecorder-based recording
// ==========================================
function startRecording(t){
  if(!inputStream){ showToast("Prima attiva l'audio!"); return; }

  // Pick best mime type
  const mimes = ["audio/webm;codecs=opus","audio/webm","audio/ogg;codecs=opus","audio/ogg","audio/mp4"];
  const mime = mimes.find(m => MediaRecorder.isTypeSupported(m)) || "";

  try {
    t.recChunks = [];
    const options = mime ? { mimeType: mime } : {};
    t.mediaRec = new MediaRecorder(inputStream, options);

    t.mediaRec.ondataavailable = (e) => {
      if(e.data && e.data.size > 0) t.recChunks.push(e.data);
    };

    t.mediaRec.onstop = async () => {
      t.isRecording = false;

      if(t.recChunks.length === 0){
        showToast("Registrazione vuota ‚Äì nessun dato catturato.");
        updateTrackUI(t);
        updateGlobalButtons();
        return;
      }

      try {
        const blob = new Blob(t.recChunks, { type: mime||"audio/webm" });
        t.recChunks = [];

        let buf = await blobToAudioBuffer(blob);

        if(buf.duration < 0.05){
          showToast("Registrazione troppo breve, riprovare.");
          updateTrackUI(t);
          updateGlobalButtons();
          return;
        }

        if(masterLoopSeconds == null){
          setMasterLoop(buf.duration);
          t.buffer = buf;
        } else {
          t.buffer = quantizeBuffer(buf);
        }

        drawWaveform(t.ui.canvas, t.buffer);
        updateTrackUI(t);
        updateGlobalButtons();
      } catch(err){
        console.error("Decode error:", err);
        showToast("Errore decodifica audio: " + err.message);
        t.isRecording = false;
        updateTrackUI(t);
        updateGlobalButtons();
      }
    };

    t.mediaRec.onerror = (e) => {
      console.error("MediaRecorder error:", e);
      showToast("Errore MediaRecorder: " + (e.error?.message||e));
      t.isRecording = false;
      updateTrackUI(t);
      updateGlobalButtons();
    };

    t.mediaRec.start(100); // collect every 100ms
    t.isRecording = true;
    updateTrackUI(t);
    updateGlobalButtons();

  } catch(err){
    console.error("Start rec error:", err);
    showToast("Impossibile avviare registrazione: " + err.message);
  }
}

function stopRecording(t){
  if(!t.mediaRec || !t.isRecording) return;
  try {
    t.mediaRec.stop(); // triggers onstop async
  } catch(err){
    console.error("Stop rec error:", err);
    t.isRecording = false;
    updateTrackUI(t);
  }
}

function toggleMainButton(t){
  if(!isInitialized){ showToast("Prima clicca ‚ö° Attiva Audio"); return; }

  if(!t.buffer){
    // No buffer yet: recording mode
    if(!t.isRecording) startRecording(t);
    else stopRecording(t);
  } else {
    // Has buffer: playback mode
    if(!t.isPlaying) startPlayback(t);
    else stopPlayback(t);
  }
}

// ==========================================
// UI
// ==========================================
function updateTrackUI(t){
  const { el, btnMain, stateTag, info, clearBtn, muteBtn, canvas } = t.ui;

  // State classes
  el.classList.toggle("is-rec", t.isRecording);
  el.classList.toggle("is-play", t.isPlaying && !t.isRecording);
  el.classList.toggle("has-buffer", !!t.buffer && !t.isPlaying && !t.isRecording);

  // State tag
  if(t.isRecording){
    stateTag.textContent = "‚óè REC";
    stateTag.className = "track-state s-rec";
  } else if(t.isPlaying){
    stateTag.textContent = "‚ñ∂ PLAY";
    stateTag.className = "track-state s-play";
  } else if(t.buffer){
    stateTag.textContent = "‚ñ† READY";
    stateTag.className = "track-state s-ready";
  } else {
    stateTag.textContent = "IDLE";
    stateTag.className = "track-state";
  }

  // Info text
  if(t.isRecording){
    info.textContent = "registrazione in corso‚Ä¶";
  } else if(t.buffer){
    info.textContent = fmtSec(t.buffer.duration);
  } else {
    info.textContent = "premi per registrare";
  }

  // Main button SVG
  const svg = btnMain.querySelector("svg");
  if(!t.buffer){
    // Record UI
    if(t.isRecording){
      // Stop square
      svg.innerHTML = `<rect x="8" y="8" width="18" height="18" rx="3" fill="rgba(255,58,58,.9)" stroke="none"/>`;
    } else {
      // Record circle
      svg.innerHTML = `<circle cx="17" cy="17" r="9" fill="rgba(255,58,58,.85)" stroke="none"/>`;
    }
  } else {
    // Playback UI
    if(t.isPlaying){
      svg.innerHTML = `<rect x="8" y="8" width="7" height="18" rx="2" fill="rgba(0,212,255,.9)" stroke="none"/>
                       <rect x="19" y="8" width="7" height="18" rx="2" fill="rgba(0,212,255,.9)" stroke="none"/>`;
    } else {
      svg.innerHTML = `<polygon points="10,8 28,17 10,26" fill="rgba(45,255,143,.9)" stroke="none"/>`;
    }
  }

  clearBtn.disabled = !t.buffer && !t.isRecording;
}

function buildTrackCard(t){
  const el = document.createElement("section");
  el.className = "track";
  el.innerHTML = `
    <div class="track-glow"></div>
    <div class="track-head">
      <div class="track-num">${String(t.index+1).padStart(2,"0")}</div>
      <span class="track-state" id="stateTag">IDLE</span>
    </div>
    <canvas class="waveform" id="cvs" width="200" height="36"></canvas>
    <div class="btn-main-wrap">
      <button class="btn-main" id="btnMain" aria-label="Record / Play">
        <div class="spin-ring"></div>
        <svg viewBox="0 0 34 34" xmlns="http://www.w3.org/2000/svg">
          <circle cx="17" cy="17" r="9" fill="rgba(255,58,58,.85)" stroke="none"/>
        </svg>
      </button>
    </div>
    <div class="track-info" id="info">premi per registrare</div>
    <div class="vol-row">
      <span class="vol-label">VOL</span>
      <input type="range" id="vol" min="0" max="1" step="0.01" value="0.85" />
      <span class="vol-pct" id="volpct">85%</span>
    </div>
    <div class="track-btns">
      <button class="btn-mute" id="muteBtn">Mute</button>
      <button class="btn-clear-t" id="clearBtn" disabled>Clear</button>
    </div>
  `;

  const btnMain = el.querySelector("#btnMain");
  const stateTag = el.querySelector("#stateTag");
  const info = el.querySelector("#info");
  const vol = el.querySelector("#vol");
  const volpct = el.querySelector("#volpct");
  const muteBtn = el.querySelector("#muteBtn");
  const clearBtn = el.querySelector("#clearBtn");
  const canvas = el.querySelector("#cvs");

  t.ui = { el, btnMain, stateTag, info, vol, volpct, muteBtn, clearBtn, canvas };

  btnMain.addEventListener("click", () => toggleMainButton(t));
  btnMain.addEventListener("keydown", e => {
    if(e.key==="Enter"||e.key===" "){ e.preventDefault(); btnMain.click(); }
  });

  vol.addEventListener("input", () => {
    const v = parseFloat(vol.value);
    volpct.textContent = Math.round(v*100)+"%";
    if(t.gainNode) t.gainNode.gain.setTargetAtTime(v, audioCtx.currentTime, 0.01);
    if(v > 0.001) t.isMuted = false;
  });

  muteBtn.addEventListener("click", () => {
    if(!t.gainNode) return;
    if(!t.isMuted){
      t._prevVol = parseFloat(vol.value);
      t.gainNode.gain.setTargetAtTime(0, audioCtx.currentTime, 0.01);
      vol.value = "0";
      volpct.textContent = "0%";
      t.isMuted = true;
      muteBtn.className = "btn-muted";
      muteBtn.textContent = "Unmute";
    } else {
      const pv = t._prevVol || 0.85;
      t.gainNode.gain.setTargetAtTime(pv, audioCtx.currentTime, 0.01);
      vol.value = String(pv);
      volpct.textContent = Math.round(pv*100)+"%";
      t.isMuted = false;
      muteBtn.className = "btn-mute";
      muteBtn.textContent = "Mute";
    }
  });

  clearBtn.addEventListener("click", () => clearTrack(t));

  updateTrackUI(t);
  return el;
}

function buildUI(){
  grid.innerHTML = "";
  tracks.length = 0;
  for(let i=0; i<TRACKS; i++){
    const t = createTrack(i);
    tracks.push(t);
    grid.appendChild(buildTrackCard(t));
  }
  updateGlobalButtons();
}

// ==========================================
// INIT
// ==========================================
async function initAudio(){
  if(isInitialized) return;

  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  srEl.textContent = audioCtx.sampleRate + " Hz";

  masterGain = audioCtx.createGain();
  masterGain.gain.value = 0.9;
  masterGain.connect(audioCtx.destination);

  // Get input stream
  const mode = sourceSelect.value;
  if(mode === "mic"){
    inputStream = await navigator.mediaDevices.getUserMedia({
      audio:{ echoCancellation:false, noiseSuppression:false, autoGainControl:false },
      video: false
    });
  } else {
    inputStream = await navigator.mediaDevices.getDisplayMedia({ audio:true, video:true });
  }

  // Create audio graph for playback (gain nodes per track)
  for(const t of tracks){
    t.gainNode = audioCtx.createGain();
    t.gainNode.gain.value = parseFloat(t.ui.vol.value);
    t.gainNode.connect(masterGain);
  }

  await audioCtx.resume();

  isInitialized = true;
  setDots();
  btnInit.textContent = "‚úì Audio attivo";
  btnInit.disabled = true;
  updateGlobalButtons();
}

// ==========================================
// GLOBAL BUTTONS
// ==========================================
btnInit.addEventListener("click", async () => {
  try {
    btnInit.textContent = "‚Ä¶attivazione";
    btnInit.disabled = true;
    await initAudio();
  } catch(e){
    console.error(e);
    btnInit.disabled = false;
    btnInit.textContent = "‚ö° Attiva Audio";
    showToast("Errore: " + (e?.message || e));
  } finally {
    setDots();
  }
});

btnPlayAll.addEventListener("click", () => {
  for(const t of tracks) if(t.buffer && !t.isPlaying) startPlayback(t);
  updateGlobalButtons();
});

btnStopAll.addEventListener("click", () => {
  for(const t of tracks){
    if(t.isPlaying) stopPlayback(t);
    if(t.isRecording) stopRecording(t);
  }
  updateGlobalButtons();
});

btnClearAll.addEventListener("click", () => {
  if(!confirm("Cancellare tutte le tracce e il loop master?")) return;
  for(const t of tracks) clearTrack(t);
  masterLoopSeconds = null;
  masterLenEl.textContent = "‚Äî";
  updateGlobalButtons();
});

sourceSelect.addEventListener("change", () => {
  if(isInitialized) showToast("Sorgente cambiata: ricarica la pagina per applicarla.");
});

// Keep dots in sync
setInterval(setDots, 600);

// Redraw waveforms on resize
window.addEventListener("resize", () => {
  for(const t of tracks) if(t.buffer) drawWaveform(t.ui.canvas, t.buffer);
});

buildUI();
</script>
</body>
</html>
