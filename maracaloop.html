<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Loopstation 8 Tracce • Metronomo Grid • Per-Track Bars • WAV Export</title>
  <style>
    :root{
      --bg:#0f1115; --text:#e7ecff; --muted:#a7b0d6;
      --stroke:#2a3247; --stroke2:#1c2232; --shadow:0 10px 30px rgba(0,0,0,.45);
      --red:#ff3b3b; --green:#44ff9a; --cyan:#4ee6ff;
      --radius:18px;
    }
    *{box-sizing:border-box}
    body{
      margin:0; color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      background: radial-gradient(1200px 700px at 30% 15%, #1a2240 0%, rgba(26,34,64,0) 55%),
                  radial-gradient(900px 500px at 80% 30%, #1a3a2f 0%, rgba(26,58,47,0) 55%),
                  var(--bg);
      min-height:100vh; display:flex; flex-direction:column; align-items:center;
    }

    header{
      width:min(1100px, 94vw); padding:18px 10px 8px;
      display:flex; align-items:flex-end; justify-content:space-between; gap:14px;
    }
    .title{font-size:28px; letter-spacing:.08em; font-weight:700; opacity:.95;}
    .top-controls{display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; align-items:center;}

    .btn{
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      color:var(--text); padding:10px 12px; border-radius:12px;
      box-shadow: 0 6px 18px rgba(0,0,0,.25);
      cursor:pointer; user-select:none;
      display:inline-flex; align-items:center; justify-content:center; gap:8px;
      white-space:nowrap;
    }
    .btn:hover{filter:brightness(1.06); border-color:#3a4566;}
    .btn:disabled{opacity:.45; cursor:not-allowed;}
    .btn-primary{border-color:rgba(78,230,255,.35);}
    .btn-good{border-color:rgba(68,255,154,.35);}
    .btn-danger{border-color:rgba(255,59,59,.35);}

    .pill{
      padding:9px 12px; border-radius:999px; border:1px solid var(--stroke);
      background: rgba(255,255,255,.03); color:var(--muted); display:flex; align-items:center; gap:10px;
    }
    .pill select, .pill input{
      background: rgba(0,0,0,.25); border:1px solid var(--stroke2);
      color:var(--text); padding:7px 10px; border-radius:10px; outline:none;
    }
    .pill input{width:100px}

    /* Metronome panel */
    .metro-wrap{ width:min(1100px, 94vw); padding: 0 10px 14px; }

    /* Sticky metronome (panel) */
    .metro-wrap{
      position: sticky;
      top: 56px; /* below floating strip */
      z-index: 800;
      background: rgba(15,17,21,.72);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(42,50,71,.35);
    }

    /* Floating metronome strip (always visible) */
    .metro-float{
      position: sticky;
      top: 0;
      z-index: 1000;
      width:min(1100px, 94vw);
      margin: 0 auto;
      padding: 10px 10px 8px;
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      background: rgba(15,17,21,.82);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-bottom:1px solid rgba(42,50,71,.55);
    }
    .mf-left{display:flex; flex-direction:column; gap:2px;}
    .mf-label{font-size:12px; letter-spacing:.12em; color:var(--muted);}
    .mf-sub{font-size:13px; color:var(--text); opacity:.9;}
    .mf-leds{display:flex; align-items:center; gap:10px;}
    .mf-leds .leds{display:flex; gap:8px; align-items:center;}
    .mf-leds .led{width:12px; height:12px;}
    .mf-leds .led.bar{width:14px; height:14px;}

    .metro{
      border:1px solid var(--stroke);
      border-radius: var(--radius);
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      box-shadow: var(--shadow);
      padding: 12px 14px;
      display:flex; flex-wrap:wrap; gap:12px;
      align-items:center; justify-content:space-between;
    }
    .metro-left{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    .metro-right{display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:flex-end;}

    .metro-group{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
      padding:8px 10px; border:1px solid var(--stroke2);
      border-radius:14px; background: rgba(0,0,0,.18);
    }
    .metro-group label{font-size:12px; color:var(--muted);}
    .metro-group input[type="range"]{width:160px; height:10px; margin:0; transform:none;}
    .metro-group input[type="range"]{
      -webkit-appearance:none; appearance:none;
      border-radius:999px; background: rgba(255,255,255,.10);
      outline:none;
    }
    .metro-group input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none; appearance:none;
      width:18px; height:18px; border-radius:50%;
      background: rgba(255,255,255,.85); border:2px solid rgba(0,0,0,.35);
      box-shadow:0 6px 18px rgba(0,0,0,.45); cursor:pointer;
    }
    .bpm{font-weight:700; min-width:64px; text-align:right;}

    .leds{display:flex; gap:8px; align-items:center;}
    .led{
      width:12px; height:12px; border-radius:50%;
      background:#3a3f52;
      box-shadow: 0 0 0 2px rgba(255,255,255,.06) inset;
      transition: transform .06s ease, filter .06s ease;
    }
    .led.on{
      background: var(--cyan);
      filter: drop-shadow(0 0 10px rgba(78,230,255,.65));
      transform: scale(1.15);
    }
    .led.bar{
      width:14px; height:14px;
      background:#4a1f1f;
    }
    .led.bar.on{
      background: var(--red);
      filter: drop-shadow(0 0 12px rgba(255,59,59,.75));
      transform: scale(1.2);
    }

    .statusbar{
      width:min(1100px, 94vw); padding:0 10px 16px;
      display:flex; gap:12px; flex-wrap:wrap; align-items:center; color:var(--muted);
    }
    .badge{
      padding:6px 10px; border:1px solid var(--stroke); background: rgba(0,0,0,.18);
      border-radius:999px; display:inline-flex; align-items:center; gap:8px;
    }
    .dot{width:10px;height:10px;border-radius:50%;background:#666; box-shadow:0 0 0 2px rgba(255,255,255,.06) inset;}
    .dot.on{background:var(--green);}
    .dot.rec{background:var(--red);}
    .dot.play{background:var(--cyan);}

    main{
      width:min(1100px, 94vw); padding:0 10px 26px;
      display:grid; grid-template-columns:repeat(4, minmax(0, 1fr)); gap:16px;
    }
    @media (max-width: 980px){ main{grid-template-columns:repeat(2, minmax(0, 1fr));} }
    @media (max-width: 520px){ main{grid-template-columns:1fr;} }

    .track{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid var(--stroke); border-radius:var(--radius);
      box-shadow:var(--shadow); padding:14px; position:relative; overflow:hidden;
      touch-action: manipulation;
    }
    .track::before{
      content:""; position:absolute; inset:-30% -40%;
      background: radial-gradient(400px 220px at 40% 35%, rgba(78,230,255,.08), rgba(0,0,0,0) 60%),
                  radial-gradient(360px 240px at 70% 65%, rgba(68,255,154,.06), rgba(0,0,0,0) 60%);
      pointer-events:none; transform:rotate(-8deg);
    }
    .track > *{position:relative;}
    .track-head{display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px;}
    .track-title{display:flex; align-items:baseline; gap:10px; flex-wrap:wrap;}
    .track-title .n{font-weight:800; font-size:18px; opacity:.95;}
    .track-title .label{font-size:13px; color:var(--muted);}
    .mini{display:flex; gap:8px; align-items:center;}
    .tag{
      font-size:12px; padding:4px 8px; border:1px solid var(--stroke2);
      border-radius:999px; color:var(--muted); background: rgba(0,0,0,.22);
      letter-spacing:.04em; text-transform:uppercase;
      white-space:nowrap;
    }
    .tag.rec{border-color:rgba(255,59,59,.35); color:#ffd0d0;}
    .tag.play{border-color:rgba(78,230,255,.35); color:#d6fbff;}
    .tag.stop{border-color:rgba(167,176,214,.35); color:var(--muted);}
    .tag.count{border-color:rgba(255,59,59,.35); color:#ffd0d0;}

    .track-body{display:grid; grid-template-columns:1fr 64px; gap:12px; align-items:center;}

    .big-btn{
      width:118px; height:118px; border-radius:999px; margin:6px auto 0;
      border:1px solid rgba(255,255,255,.10);
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.12), rgba(0,0,0,.25) 60%),
                  rgba(0,0,0,.20);
      display:grid; place-items:center; cursor:pointer; user-select:none;
      box-shadow:0 18px 40px rgba(0,0,0,.45); position:relative;
    }
    .big-btn .ring{position:absolute; inset:-8px; border-radius:999px; border:10px solid rgba(255,59,59,.75);
      border-top-color:rgba(255,59,59,.18); border-left-color:rgba(255,59,59,.45); opacity:.85;}
    .big-btn .ring2{position:absolute; inset:10px; border-radius:999px; border:6px solid rgba(68,255,154,.55);
      border-right-color:rgba(68,255,154,.15); border-bottom-color:rgba(68,255,154,.35); opacity:.85;}
    .icon{
      width:54px; height:54px; border-radius:999px; display:grid; place-items:center;
      background: rgba(0,0,0,.35); border:1px solid rgba(255,255,255,.10);
    }
    .big-btn svg{width:30px; height:30px; fill:none; stroke-width:2.4;}

    .fader{
      display:flex; flex-direction:column; align-items:center; gap:8px;
      padding:8px 6px; border-radius:14px; border:1px solid var(--stroke2); background: rgba(0,0,0,.18);
    }
    .fader label{font-size:12px; color:var(--muted);}
    input[type="range"].vol{
      -webkit-appearance:none; appearance:none;
      width:140px; height:10px; border-radius:999px; background: rgba(255,255,255,.10);
      outline:none; transform: rotate(-90deg); margin:54px 0;
    }
    input[type="range"].vol::-webkit-slider-thumb{
      -webkit-appearance:none; appearance:none;
      width:18px; height:18px; border-radius:50%;
      background: rgba(255,255,255,.85); border:2px solid rgba(0,0,0,.35);
      box-shadow:0 6px 18px rgba(0,0,0,.45); cursor:pointer;
    }

    .track-actions{display:flex; gap:8px; margin-top:12px; justify-content:space-between; flex-wrap:wrap;}
    .track-actions .btn{padding:9px 10px; border-radius:12px; flex:1; justify-content:center; min-width:96px;}

    .track-settings{
      display:flex; gap:8px; flex-wrap:wrap; margin-top:10px;
      padding:10px; border-radius:14px; border:1px solid var(--stroke2);
      background: rgba(0,0,0,.18);
    }
    .track-settings .pill{padding:6px 10px}
    .track-settings .pill select{padding:6px 8px}
    .track-settings .pill span{font-size:12px; color:var(--muted);}

    .footer-note{width:min(1100px, 94vw); padding:0 10px 26px; color:var(--muted); font-size:13px; line-height:1.4;}
    code{background:rgba(0,0,0,.25); padding:2px 6px; border-radius:8px; border:1px solid var(--stroke2);}
  </style>
</head>
<body>

  <header>
    <div class="title">maracaloop A</div>
    <div class="top-controls">
      <div class="pill">
        <span>Sorgente</span>
        <select id="sourceSelect" aria-label="Sorgente audio">
          <option value="mic">Microfono</option>
          <option value="screen">Scheda/Schermo con audio (se supportato)</option>
        </select>
      </div>
      <button class="btn btn-primary" id="btnInit">1) Attiva Audio</button>
      <button class="btn btn-good" id="btnPlayAll" disabled>Play All</button>
      <button class="btn btn-danger" id="btnStopAll" disabled>Stop All</button>
      <button class="btn" id="btnClearAll" disabled>Clear All</button>
      <button class="btn" id="btnSaveAll" disabled>Save ALL WAV</button>
    </div>
  </header>

  <!-- Metronome floating strip (always visible) -->
  <div class="metro-float" aria-label="Metronomo sempre visibile">
    <div class="mf-left">
      <span class="mf-label">METRO</span>
      <span class="mf-sub"><span id="mfBpm">90</span> BPM • <span id="mfSig">4/4</span></span>
    </div>
    <div class="mf-leds">
      <div class="leds" id="beatLedsFloat"></div>
      <span class="led bar" id="barLedFloat"></span>
    </div>
  </div>

  <div class="metro-wrap">
    <div class="metro">
      <div class="metro-left">
        <div class="metro-group">
          <label>Metronomo</label>
          <button class="btn" id="btnMetro">ON</button>
        </div>

        <div class="metro-group">
          <label>BPM</label>
          <input id="bpm" type="range" min="60" max="120" step="1" value="90">
          <div class="bpm"><span id="bpmVal">90</span></div>
        </div>

        <div class="metro-group">
          <label>Misura</label>
          <select id="tsig">
            <option value="3">3/4</option>
            <option value="4" selected>4/4</option>
            <option value="5">5/4</option>
            <option value="7">7/4</option>
          </select>
        </div>

        <div class="metro-group">
          <label>LED 1/4</label>
          <div class="leds" id="beatLeds"></div>
          <div class="leds" title="Downbeat">
            <span class="led bar" id="barLed"></span>
          </div>
        </div>
      </div>

      <div class="metro-right">
        <div class="metro-group">
          <label>Sync start</label>
          <select id="syncMode">
            <option value="on" selected>ON</option>
            <option value="off">OFF</option>
          </select>
        </div>

        <div class="metro-group">
          <label>Anticipo REC</label>
          <input id="leadMs" type="number" min="0" max="2000" step="10" value="880" />
          <label style="min-width:68px">ms</label>
        </div>

        <div class="metro-group">
          <label>Extra fine (1/4)</label>
          <select id="extraBeats">
            <option value="0">0</option>
            <option value="1">1</option>
            <option value="2" selected>2</option>
            <option value="3">3</option>
            <option value="4">4</option>
          </select>
        </div>
      </div>
    </div>
  </div>

  <div class="statusbar">
    <div class="badge"><span class="dot" id="dotAudio"></span> AudioContext</div>
    <div class="badge"><span class="dot" id="dotInput"></span> Ingresso</div>
    <div class="badge">Beat: <b id="beatMs">—</b> ms • Bar: <b id="barMs">—</b> ms</div>
    <div class="badge">SampleRate: <b id="sr">—</b></div>
    <div class="badge">Codec REC: <b id="codec">—</b></div>
  </div>

  <main id="grid"></main>

  <div class="footer-note">
    <ul>
      <li>Ogni traccia esporta un file <b>.wav</b> (PCM 16-bit) della lunghezza completa della traccia.</li>
      <li>Su Chrome Android, il download può aprire il file invece di salvarlo: dipende dalle impostazioni del device.</li>
    </ul>
  </div>

<script>
(() => {
  const TRACKS = 8;

  let audioCtx = null;
  let inputStream = null;
  let masterGain = null;

  // Grid transport
  let gridStartTime = null;

  // Metronome (visual, mute)
  let metroOn = false;
  let metroTimer = null;
  let metroBeatIndex = 0;
  let nextBeatAtMs = 0;

  // Per-track countdown + schedule
  const countdowns = new Map(); // trackIndex -> state
  const schedules = new Map();  // trackIndex -> {startTimeout, stopTimeout}

  const gridEl = document.getElementById("grid");
  const btnInit = document.getElementById("btnInit");
  const btnPlayAll = document.getElementById("btnPlayAll");
  const btnStopAll = document.getElementById("btnStopAll");
  const btnClearAll = document.getElementById("btnClearAll");
  const btnSaveAll = document.getElementById("btnSaveAll");
  const sourceSelect = document.getElementById("sourceSelect");

  const dotAudio = document.getElementById("dotAudio");
  const dotInput = document.getElementById("dotInput");
  const srEl = document.getElementById("sr");
  const codecEl = document.getElementById("codec");
  const beatMsEl = document.getElementById("beatMs");
  const barMsEl = document.getElementById("barMs");

  const btnMetro = document.getElementById("btnMetro");
  const bpm = document.getElementById("bpm");
  const bpmVal = document.getElementById("bpmVal");
  const tsig = document.getElementById("tsig");
  const beatLeds = document.getElementById("beatLeds");
  const barLed = document.getElementById("barLed");
  const beatLedsFloat = document.getElementById("beatLedsFloat");
  const barLedFloat = document.getElementById("barLedFloat");
  const mfBpm = document.getElementById("mfBpm");
  const mfSig = document.getElementById("mfSig");

  const syncModeSel = document.getElementById("syncMode");
  const leadMsEl = document.getElementById("leadMs");
  const extraBeatsSel = document.getElementById("extraBeats");

  const tracks = [];

  function syncOn(){ return syncModeSel.value === "on"; }
  function getLeadSeconds(){ return Math.max(0, parseFloat(leadMsEl.value || "0") / 1000); }
  function getExtraBeats(){ return parseInt(extraBeatsSel.value, 10); }

  function getBpm(){ return parseInt(bpm.value, 10); }
  function getNumerator(){ return parseInt(tsig.value, 10); }
  function beatSeconds(){ return 60 / getBpm(); }
  function barSeconds(){ return getNumerator() * beatSeconds(); }

  function updateTimingBadges(){
    beatMsEl.textContent = String(Math.round(beatSeconds()*1000));
    barMsEl.textContent = String(Math.round(barSeconds()*1000));
  }

  function setDots(){
    dotAudio.classList.toggle("on", !!audioCtx && audioCtx.state === "running");
    dotInput.classList.toggle("on", !!inputStream);
  }

  function anyBuffers(){ return tracks.some(t => !!t.buffer); }

  function updateGlobalButtons(){
    const anyHasBuffer = anyBuffers();
    const anyPlaying = tracks.some(t => t.isPlaying);
    const anyBusy = tracks.some(t => t.isRecording || t.isArmedRecord || t.isCountingIn);

    btnPlayAll.disabled = !audioCtx || !anyHasBuffer;
    btnStopAll.disabled = !audioCtx || (!anyPlaying && !anyBusy);
    btnClearAll.disabled = !audioCtx || !anyHasBuffer;
    btnSaveAll.disabled = !anyHasBuffer;
  }

  function pickBestMimeType(){
    const candidates = [
      'audio/webm;codecs=opus',
      'audio/webm',
      'audio/mp4',
      'audio/ogg;codecs=opus',
      'audio/ogg'
    ];
    for (const c of candidates){
      if (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(c)) return c;
    }
    return '';
  }

  function ensureGridStartArmed(){
    if (!audioCtx) return;
    if (gridStartTime != null) return;
    gridStartTime = audioCtx.currentTime + 0.40;
  }

  function nextBarTime(fromTime){
    if (!syncOn() || gridStartTime == null) return fromTime;
    const bar = barSeconds();
    const t = Math.max(fromTime, audioCtx.currentTime);
    const rel = t - gridStartTime;
    const barsPassed = Math.ceil(rel / bar);
    return gridStartTime + barsPassed * bar;
  }

  // LEDs
  function buildBeatLeds(){
    beatLeds.innerHTML = "";
    if (beatLedsFloat) beatLedsFloat.innerHTML = "";
    const n = getNumerator();
    for (let i = 0; i < n; i++){
      const s = document.createElement("span");
      s.className = "led";
      beatLeds.appendChild(s);
      if (beatLedsFloat){
        const f = document.createElement("span");
        f.className = "led";
        beatLedsFloat.appendChild(f);
      }
    }
    metroBeatIndex = 0;
  }

  function flashBeat(i){
    const leds = beatLeds.querySelectorAll(".led");
    leds.forEach((l, idx) => l.classList.toggle("on", idx === i));
    const fLeds = beatLedsFloat ? beatLedsFloat.querySelectorAll(".led") : null;
    if (fLeds) fLeds.forEach((l, idx) => l.classList.toggle("on", idx === i));
    if (i === 0){
      barLed.classList.add("on");
      if (barLedFloat) barLedFloat.classList.add("on");
      setTimeout(() => {
        barLed.classList.remove("on");
        if (barLedFloat) barLedFloat.classList.remove("on");
      }, 110);
    }
    setTimeout(() => {
      const l = leds[i];
      if (l) l.classList.remove("on");
      if (fLeds){
        const fl = fLeds[i];
        if (fl) fl.classList.remove("on");
      }
    }, 90);
  }

  function stopMetronome(){
    metroOn = false;
    btnMetro.textContent = "ON";
    if (metroTimer) clearTimeout(metroTimer);
    metroTimer = null;
    beatLeds.querySelectorAll(".led").forEach(l => l.classList.remove("on"));
    if (beatLedsFloat) beatLedsFloat.querySelectorAll(".led").forEach(l => l.classList.remove("on"));
    barLed.classList.remove("on");
    if (barLedFloat) barLedFloat.classList.remove("on");
  }

  function startMetronome(){
    metroOn = true;
    btnMetro.textContent = "OFF";
    metroBeatIndex = 0;
    nextBeatAtMs = performance.now();

    const tick = () => {
      if (!metroOn) return;
      const now = performance.now();
      if (now >= nextBeatAtMs - 1){
        flashBeat(metroBeatIndex);
        metroBeatIndex = (metroBeatIndex + 1) % getNumerator();
        nextBeatAtMs += beatSeconds() * 1000;
      }
      metroTimer = setTimeout(tick, 10);
    };

    tick();
  }

  // Input
  async function getInputStream(){
    const mode = sourceSelect.value;
    if (mode === "mic"){
      return await navigator.mediaDevices.getUserMedia({
        audio: { echoCancellation:false, noiseSuppression:false, autoGainControl:false },
        video: false
      });
    }
    return await navigator.mediaDevices.getDisplayMedia({ audio:true, video:true });
  }

  function stopAllInput(){
    if (inputStream){
      for (const tr of inputStream.getTracks()) tr.stop();
      inputStream = null;
    }
  }

  // WAV export (PCM 16-bit, little-endian)
  function audioBufferToWavBlob(buffer){
    const numCh = buffer.numberOfChannels;
    const sr = buffer.sampleRate;
    const numFrames = buffer.length;

    // Interleave
    const interleaved = new Float32Array(numFrames * numCh);
    for (let ch=0; ch<numCh; ch++){
      const data = buffer.getChannelData(ch);
      for (let i=0; i<numFrames; i++){
        interleaved[i*numCh + ch] = data[i];
      }
    }

    // 16-bit PCM
    const bytesPerSample = 2;
    const blockAlign = numCh * bytesPerSample;
    const byteRate = sr * blockAlign;
    const dataSize = interleaved.length * bytesPerSample;
    const bufferSize = 44 + dataSize;

    const ab = new ArrayBuffer(bufferSize);
    const view = new DataView(ab);

    function writeStr(offset, str){
      for (let i=0; i<str.length; i++) view.setUint8(offset+i, str.charCodeAt(i));
    }

    // RIFF header
    writeStr(0, "RIFF");
    view.setUint32(4, 36 + dataSize, true);
    writeStr(8, "WAVE");

    // fmt chunk
    writeStr(12, "fmt ");
    view.setUint32(16, 16, true);          // PCM chunk size
    view.setUint16(20, 1, true);           // audio format = PCM
    view.setUint16(22, numCh, true);
    view.setUint32(24, sr, true);
    view.setUint32(28, byteRate, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, 16, true);          // bits per sample

    // data chunk
    writeStr(36, "data");
    view.setUint32(40, dataSize, true);

    // samples
    let offset = 44;
    for (let i=0; i<interleaved.length; i++){
      let s = interleaved[i];
      // clamp
      if (s > 1) s = 1;
      if (s < -1) s = -1;
      // scale
      const int16 = s < 0 ? Math.round(s * 32768) : Math.round(s * 32767);
      view.setInt16(offset, int16, true);
      offset += 2;
    }

    return new Blob([ab], { type: "audio/wav" });
  }

  function downloadBlob(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    // revoke later to allow download to start
    setTimeout(() => URL.revokeObjectURL(url), 2000);
  }

  function safeFileName(s){
    return String(s).replace(/[^\w\-\.]+/g, "_");
  }

  function trackWavName(t){
    const bpmVal = getBpm();
    const ts = getNumerator();
    const ms = t.buffer ? Math.round(t.buffer.duration*1000) : 0;
    return safeFileName(`track_${t.index+1}_${t.bars}bars_${ts}-4_${bpmVal}bpm_${ms}ms.wav`);
  }

  // Tracks
  function createTrack(index){
    return {
      index,
      buffer: null,
      source: null,
      gainNode: null,

      recorder: null,
      recChunks: [],
      isRecording: false,
      isPlaying: false,
      isCountingIn: false,
      isArmedRecord: false,

      // config
      bars: 8,
      countInBars: 4,

      // planned alignment
      plannedLeadSec: 0,
      plannedLenSec: 0,

      loopCount: 0,
      loopTimer: null,

      longPressTimer: null,
      longPressFired: false,

      ui: {}
    };
  }

  function stopLoopCounter(t){
    if (t.loopTimer){
      clearInterval(t.loopTimer);
      t.loopTimer = null;
    }
    t.loopCount = 0;
  }

  function startLoopCounter(t){
    stopLoopCounter(t);
    t.loopCount = 0;
    const dur = t.buffer?.duration;
    if (!dur || !isFinite(dur) || dur <= 0.01) return;

    t.loopTimer = setInterval(() => {
      if (!t.isPlaying) return;
      t.loopCount++;
      updateTrackUI(t);
    }, Math.max(50, dur * 1000));
  }

  function stopPlayback(t){
    if (t.source){
      try { t.source.stop(); } catch {}
      try { t.source.disconnect(); } catch {}
      t.source = null;
    }
    t.isPlaying = false;
    stopLoopCounter(t);
    updateTrackUI(t);
    updateGlobalButtons();
  }

  function startPlayback(t){
    if (!audioCtx || !t.buffer) return;

    stopPlayback(t);

    const src = audioCtx.createBufferSource();
    src.buffer = t.buffer;
    src.loop = true;
    src.loopStart = 0;
    src.loopEnd = t.buffer.duration;
    src.connect(t.gainNode);

    let startAt = audioCtx.currentTime + 0.02;
    if (syncOn()){
      ensureGridStartArmed();
      startAt = nextBarTime(audioCtx.currentTime + 0.05);
    }
    try { src.start(startAt); } catch { src.start(); }

    t.source = src;
    t.isPlaying = true;
    startLoopCounter(t);

    updateTrackUI(t);
    updateGlobalButtons();
  }

  function cancelCountdown(t){
    const st = countdowns.get(t.index);
    if (!st) return;
    st.active = false;
    if (st.timer) clearTimeout(st.timer);
    countdowns.delete(t.index);

    t.isCountingIn = false;
    t.ui.countBadge.style.display = "none";
    updateTrackUI(t);
    updateGlobalButtons();
  }

  function cancelSchedule(t){
    const sch = schedules.get(t.index);
    if (!sch) return;
    if (sch.startTimeout) clearTimeout(sch.startTimeout);
    if (sch.stopTimeout) clearTimeout(sch.stopTimeout);
    schedules.delete(t.index);

    t.isArmedRecord = false;
    updateTrackUI(t);
    updateGlobalButtons();
  }

  function clearTrack(t){
    cancelCountdown(t);
    cancelSchedule(t);
    if (t.isRecording) stopRecording(t, { autoPlay:false });

    stopPlayback(t);
    t.buffer = null;

    updateTrackUI(t);
    updateGlobalButtons();
  }

  function startCountdownThenRecord(t){
    cancelCountdown(t);

    const barsToCount = Math.max(0, parseInt(t.countInBars, 10) || 0);
    if (barsToCount === 0){
      armRecordWithGrid(t);
      return;
    }

    const wasMetroOn = metroOn;
    if (!metroOn) startMetronome();

    t.isCountingIn = true;
    updateTrackUI(t);
    updateGlobalButtons();

    const state = {
      active: true,
      timer: null,
      beatGlobal: 0,
      barsToCount,
      beatsPerBar: getNumerator(),
      totalBeats: barsToCount * getNumerator(),
      wasMetroOn
    };
    countdowns.set(t.index, state);

    const beatMs = beatSeconds() * 1000;

    const step = () => {
      const st = countdowns.get(t.index);
      if (!st || !st.active) return;

      const barIdx = Math.floor(st.beatGlobal / st.beatsPerBar);
      const beatInBar = st.beatGlobal % st.beatsPerBar;

      t.ui.countBadge.textContent = `COUNT ${barIdx}:${beatInBar}`;
      t.ui.countBadge.style.display = "inline-flex";

      flashBeat(beatInBar);

      st.beatGlobal++;

      if (st.beatGlobal >= st.totalBeats){
        t.ui.countBadge.style.display = "none";
        t.isCountingIn = false;
        countdowns.delete(t.index);
        updateTrackUI(t);
        updateGlobalButtons();

        if (!st.wasMetroOn) stopMetronome();
        armRecordWithGrid(t);
        return;
      }

      st.timer = setTimeout(step, beatMs);
    };

    step();
  }

  // Buffer helpers
  async function blobToAudioBuffer(blob){
    const arrayBuf = await blob.arrayBuffer();
    return await audioCtx.decodeAudioData(arrayBuf);
  }

  function mixToMonoIfNeeded(decoded){
    if (decoded.numberOfChannels <= 1) return decoded;
    const mono = audioCtx.createBuffer(1, decoded.length, decoded.sampleRate);
    const out = mono.getChannelData(0);
    for (let ch=0; ch<decoded.numberOfChannels; ch++){
      const d = decoded.getChannelData(ch);
      for (let i=0; i<d.length; i++) out[i] += d[i] / decoded.numberOfChannels;
    }
    return mono;
  }

  function sliceBuffer(buf, startSec, lengthSec){
    const sr = buf.sampleRate;
    const start = Math.max(0, Math.round(startSec * sr));
    const len = Math.max(1, Math.round(lengthSec * sr));
    const end = Math.min(buf.length, start + len);

    const chs = buf.numberOfChannels;
    const out = audioCtx.createBuffer(chs, len, sr);
    for (let ch=0; ch<chs; ch++){
      const inData = buf.getChannelData(ch);
      const outData = out.getChannelData(ch);
      const segment = inData.subarray(start, end);
      outData.set(segment);
    }
    return out;
  }

  function startRecordingNow(t){
    if (!audioCtx || !inputStream) return;
    if (!window.MediaRecorder) return alert("MediaRecorder non disponibile in questo browser.");
    if (t.isRecording) return;

    stopPlayback(t);

    t.recChunks = [];
    const mime = pickBestMimeType();
    codecEl.textContent = mime || "(auto)";

    let rec;
    try {
      rec = new MediaRecorder(inputStream, mime ? { mimeType: mime } : undefined);
    } catch {
      rec = new MediaRecorder(inputStream);
      codecEl.textContent = "(fallback)";
    }

    t.recorder = rec;
    t.isRecording = true;
    t.isArmedRecord = false;

    rec.ondataavailable = (ev) => {
      if (ev.data && ev.data.size > 0) t.recChunks.push(ev.data);
    };

    rec.onerror = (ev) => {
      console.error("Recorder error", ev);
      alert("Errore registrazione: " + (ev?.error?.message || ev?.message || ev));
      t.isRecording = false;
      t.recorder = null;
      t.recChunks = [];
      updateTrackUI(t);
      updateGlobalButtons();
    };

    rec.start(250);
    updateTrackUI(t);
    updateGlobalButtons();
  }

  function stopRecording(t, { autoPlay } = { autoPlay: true }){
    if (!t.recorder || !t.isRecording) return;

    const rec = t.recorder;

    rec.onstop = async () => {
      try{
        const blob = new Blob(t.recChunks, { type: rec.mimeType || 'audio/webm' });
        if (blob.size < 2000){
          t.buffer = null;
          return;
        }

        const decoded = await blobToAudioBuffer(blob);
        const mono = mixToMonoIfNeeded(decoded);

        const loopLen = t.plannedLenSec || (Math.max(1, t.bars) * barSeconds());
        const extraEnd = getExtraBeats() * beatSeconds();
        const trimStart = Math.max(0, t.plannedLeadSec || 0);

        const trimmed = sliceBuffer(mono, trimStart, loopLen + extraEnd);
        const fixed = sliceBuffer(trimmed, 0, loopLen);

        t.buffer = fixed;

        if (autoPlay) startPlayback(t);
      } catch (e){
        console.error(e);
        alert("Errore decodifica audio: " + (e?.message || e));
      } finally {
        t.isRecording = false;
        t.recorder = null;
        t.recChunks = [];
        t.plannedLeadSec = 0;
        t.plannedLenSec = 0;

        updateTrackUI(t);
        updateGlobalButtons();
      }
    };

    try { rec.stop(); } catch {}
    updateTrackUI(t);
    updateGlobalButtons();
  }

  function armRecordWithGrid(t){
    if (!audioCtx) return;

    if (syncOn()) ensureGridStartArmed();

    const bars = Math.max(1, parseInt(t.bars, 10) || 1);
    const loopLen = bars * barSeconds();

    const desiredStartAt = syncOn()
      ? nextBarTime(audioCtx.currentTime + 0.05)
      : (audioCtx.currentTime + 0.05);

    const lead = getLeadSeconds();
    const recorderStartAt = Math.max(audioCtx.currentTime + 0.02, desiredStartAt - lead);
    const effectiveLead = Math.max(0, desiredStartAt - recorderStartAt);

    const extraEnd = getExtraBeats() * beatSeconds();
    const recorderStopAt = desiredStartAt + loopLen + extraEnd;

    t.isArmedRecord = true;
    t.plannedLeadSec = effectiveLead;
    t.plannedLenSec = loopLen;

    updateTrackUI(t);
    updateGlobalButtons();

    const now = audioCtx.currentTime;
    const startDelayMs = Math.max(0, (recorderStartAt - now) * 1000);
    const stopDelayMs  = Math.max(0, (recorderStopAt  - now) * 1000);

    cancelSchedule(t);

    const startTimeout = setTimeout(() => startRecordingNow(t), startDelayMs);
    const stopTimeout  = setTimeout(() => stopRecording(t, { autoPlay:true }), stopDelayMs);

    schedules.set(t.index, { startTimeout, stopTimeout });

    t.ui.countBadge.textContent = `ARM • ${bars} bars`;
    t.ui.countBadge.style.display = "inline-flex";
    setTimeout(() => {
      if (!t.isCountingIn && !t.isRecording) t.ui.countBadge.style.display = "none";
    }, 1200);
  }

  async function onMainTap(t){
    if (!audioCtx) return alert("Prima clicca: Attiva Audio");
    try { await audioCtx.resume(); } catch {}

    if (t.isCountingIn){
      cancelCountdown(t);
      return;
    }
    if (t.isArmedRecord){
      cancelSchedule(t);
      return;
    }
    if (!t.buffer && !t.isRecording){
      if (syncOn()) ensureGridStartArmed();
      startCountdownThenRecord(t);
      return;
    }
    if (t.isRecording){
      stopRecording(t, { autoPlay:true });
      return;
    }

    if (t.isPlaying) stopPlayback(t);
    else startPlayback(t);
  }

  function updateTrackUI(t){
    const { btnMain, tag, label, dot, vol, volpct, muteBtn, clearBtn, saveBtn } = t.ui;

    if (t.isCountingIn){
      tag.textContent = "COUNT";
      tag.className = "tag count";
      dot.className = "dot rec";
      label.textContent = `count-in (${t.countInBars} bars)…`;
    } else if (t.isArmedRecord){
      tag.textContent = "ARM";
      tag.className = "tag rec";
      dot.className = "dot rec";
      label.textContent = `armed • rec ${t.bars} bars`;
    } else if (t.isRecording){
      tag.textContent = "REC";
      tag.className = "tag rec";
      dot.className = "dot rec";
      label.textContent = `registrazione… (${t.bars} bars)`;
    } else if (t.isPlaying){
      tag.textContent = "PLAY";
      tag.className = "tag play";
      dot.className = "dot play";
      const lc = t.loopCount ? (" • x" + t.loopCount) : "";
      label.textContent = `in loop (${t.bars} bars)` + lc;
    } else {
      tag.textContent = "STOP";
      tag.className = "tag stop";
      dot.className = "dot";
      label.textContent = t.buffer ? (`pronto • ${t.bars} bars • ${Math.round(t.buffer.duration*1000)}ms`) : `vuoto • ${t.bars} bars`;
    }

    const svg = btnMain.querySelector("svg");
    const path = svg.querySelector("path");

    if (t.isCountingIn || t.isArmedRecord){
      path.setAttribute("d", "M16 10a6 6 0 1 0 0 12a6 6 0 0 0 0-12Z");
      svg.style.stroke = "rgba(255,59,59,.95)";
    } else if (!t.buffer){
      if (t.isRecording){
        path.setAttribute("d", "M9 9h14v14H9z");
        svg.style.stroke = "rgba(255,59,59,.95)";
      } else {
        path.setAttribute("d", "M16 10a6 6 0 1 0 0 12a6 6 0 0 0 0-12Z");
        svg.style.stroke = "rgba(255,59,59,.95)";
      }
    } else {
      if (t.isPlaying){
        path.setAttribute("d", "M9 9h14v14H9z");
        svg.style.stroke = "rgba(78,230,255,.95)";
      } else {
        path.setAttribute("d", "M12 10l12 6-12 6V10z");
        svg.style.stroke = "rgba(68,255,154,.95)";
      }
    }

    clearBtn.disabled = (!t.buffer && !t.isRecording && !t.isCountingIn && !t.isArmedRecord);
    muteBtn.disabled = !t.gainNode;
    saveBtn.disabled = !t.buffer;

    const v = parseFloat(vol.value);
    volpct.textContent = Math.round(v*100) + "%";
  }

  function attachLongPress(t, btnMain){
    const start = (ev) => {
      ev.preventDefault();
      t.longPressFired = false;
      t.longPressTimer = setTimeout(() => {
        t.longPressFired = true;
        if (!t.buffer && !t.isRecording && !t.isCountingIn && !t.isArmedRecord) return;
        const ok = confirm(`Cancellare traccia ${t.index+1}?`);
        if (ok) clearTrack(t);
      }, 3000);
    };

    const end = () => {
      if (t.longPressTimer) clearTimeout(t.longPressTimer);
      t.longPressTimer = null;
    };

    btnMain.addEventListener("pointerdown", start, { passive:false });
    btnMain.addEventListener("pointerup", end);
    btnMain.addEventListener("pointercancel", end);
    btnMain.addEventListener("pointerleave", end);

    btnMain.addEventListener("click", (ev) => {
      if (t.longPressFired){
        ev.preventDefault();
        ev.stopPropagation();
        t.longPressFired = false;
        return;
      }
      onMainTap(t);
    });
  }

  function buildTrackCard(t){
    const el = document.createElement("section");
    el.className = "track";
    el.innerHTML = `
      <div class="track-head">
        <div class="track-title">
          <div class="n">${t.index+1}</div>
          <div class="label" id="label">vuoto</div>
          <span class="tag count" id="countBadge" style="display:none;"></span>
        </div>
        <div class="mini">
          <span class="dot" id="dot"></span>
          <span class="tag stop" id="tag">STOP</span>
        </div>
      </div>

      <div class="track-body">
        <div style="text-align:center;">
          <div class="big-btn" id="btnMain" role="button" tabindex="0" aria-label="Record/Play (long press = clear)">
            <div class="ring"></div>
            <div class="ring2"></div>
            <div class="icon">
              <svg viewBox="0 0 32 32" stroke="rgba(255,59,59,.95)">
                <path d="M16 10a6 6 0 1 0 0 12a6 6 0 0 0 0-12Z"></path>
              </svg>
            </div>
          </div>
        </div>

        <div class="fader">
          <label>VOL</label>
          <input class="vol" id="vol" type="range" min="0" max="1" step="0.01" value="0.85" />
          <label id="volpct">85%</label>
        </div>
      </div>

      <div class="track-settings">
        <div class="pill">
          <span>REC</span>
          <select id="barsSel">
            <option>1</option><option>2</option><option>4</option><option selected>8</option><option>16</option><option>32</option>
          </select>
          <span>bars</span>
        </div>
        <div class="pill">
          <span>COUNT</span>
          <select id="countSel">
            <option value="0">0</option>
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="4" selected>4</option>
            <option value="8">8</option>
          </select>
          <span>bars</span>
        </div>
      </div>

      <div class="track-actions">
        <button class="btn" id="saveBtn">Save WAV</button>
        <button class="btn" id="muteBtn">Mute</button>
        <button class="btn" id="clearBtn">Clear</button>
      </div>
    `;

    const btnMain = el.querySelector("#btnMain");
    const tag = el.querySelector("#tag");
    const label = el.querySelector("#label");
    const dot = el.querySelector("#dot");
    const vol = el.querySelector("#vol");
    const volpct = el.querySelector("#volpct");
    const saveBtn = el.querySelector("#saveBtn");
    const muteBtn = el.querySelector("#muteBtn");
    const clearBtn = el.querySelector("#clearBtn");
    const barsSel = el.querySelector("#barsSel");
    const countSel = el.querySelector("#countSel");
    const countBadge = el.querySelector("#countBadge");

    t.ui = { el, btnMain, tag, label, dot, vol, volpct, saveBtn, muteBtn, clearBtn, barsSel, countSel, countBadge };

    barsSel.addEventListener("change", () => {
      t.bars = parseInt(barsSel.value, 10);
      updateTrackUI(t);
      updateGlobalButtons();
    });
    countSel.addEventListener("change", () => {
      t.countInBars = parseInt(countSel.value, 10);
      updateTrackUI(t);
    });

    attachLongPress(t, btnMain);

    btnMain.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") { e.preventDefault(); btnMain.click(); }
    });

    vol.addEventListener("input", () => {
      const v = parseFloat(vol.value);
      if (t.gainNode) t.gainNode.gain.value = v;
      updateTrackUI(t);
    });

    muteBtn.addEventListener("click", () => {
      if (!t.gainNode) return;
      const currently = t.gainNode.gain.value;
      if (currently > 0.0001){
        t._prevVol = parseFloat(vol.value);
        t.gainNode.gain.value = 0;
        vol.value = "0";
      } else {
        const pv = (t._prevVol != null) ? t._prevVol : 0.85;
        t.gainNode.gain.value = pv;
        vol.value = String(pv);
      }
      vol.dispatchEvent(new Event("input"));
    });

    clearBtn.addEventListener("click", () => {
      const ok = confirm(`Cancellare traccia ${t.index+1}?`);
      if (ok) clearTrack(t);
    });

    saveBtn.addEventListener("click", () => {
      if (!t.buffer) return;
      const wav = audioBufferToWavBlob(t.buffer);
      downloadBlob(wav, trackWavName(t));
    });

    updateTrackUI(t);
    return el;
  }

  function buildUI(){
    gridEl.innerHTML = "";
    tracks.length = 0;
    for (let i=0; i<TRACKS; i++){
      const t = createTrack(i);
      tracks.push(t);
      gridEl.appendChild(buildTrackCard(t));
    }
    updateGlobalButtons();
  }

  async function initAudio(){
    if (audioCtx) return;

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    srEl.textContent = audioCtx.sampleRate + " Hz";

    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.95;
    masterGain.connect(audioCtx.destination);

    inputStream = await getInputStream();

    for (const t of tracks){
      t.gainNode = audioCtx.createGain();
      t.gainNode.gain.value = parseFloat(t.ui.vol.value);
      t.gainNode.connect(masterGain);
    }

    await audioCtx.resume();
    setDots();

    btnInit.textContent = "Audio attivo";
    btnInit.disabled = true;
    updateGlobalButtons();
  }

  // Global controls
  btnInit.addEventListener("click", async () => {
    try{
      await initAudio();
    } catch (e){
      console.error(e);
      alert("Impossibile attivare audio: " + (e?.message || e));
      stopAllInput();
    } finally {
      setDots();
      updateGlobalButtons();
    }
  });

  btnPlayAll.addEventListener("click", () => {
    for (const t of tracks) if (t.buffer && !t.isPlaying) startPlayback(t);
    updateGlobalButtons();
  });

  btnStopAll.addEventListener("click", () => {
    for (const t of tracks){
      cancelCountdown(t);
      cancelSchedule(t);
      if (t.isRecording) stopRecording(t, { autoPlay:false });
      if (t.isPlaying) stopPlayback(t);
      t.ui.countBadge.style.display = "none";
    }
    updateGlobalButtons();
  });

  btnClearAll.addEventListener("click", () => {
    if (!confirm("Cancellare tutte le tracce?")) return;
    for (const t of tracks) clearTrack(t);
    gridStartTime = null;
    updateGlobalButtons();
  });

  btnSaveAll.addEventListener("click", () => {
    const list = tracks.filter(t => !!t.buffer);
    if (!list.length) return;
    // Download sequentially with small delay (Android/Chrome can block multiple immediate downloads)
    let i = 0;
    const next = () => {
      if (i >= list.length) return;
      const t = list[i++];
      try{
        const wav = audioBufferToWavBlob(t.buffer);
        downloadBlob(wav, trackWavName(t));
      } finally {
        setTimeout(next, 700);
      }
    };
    next();
  });

  sourceSelect.addEventListener("change", () => {
    if (audioCtx){
      alert("Hai cambiato sorgente. Ricarica la pagina per applicarla.");
    }
  });

  btnMetro.addEventListener("click", () => {
    if (metroOn) stopMetronome();
    else startMetronome();
  });

  function onTimingChange(){
    bpmVal.textContent = bpm.value;
    if (mfBpm) mfBpm.textContent = bpm.value;
    if (mfSig) mfSig.textContent = tsig.value + "/4";
    updateTimingBadges();
    buildBeatLeds();

    for (const t of tracks){
      cancelCountdown(t);
      cancelSchedule(t);
      t.ui.countBadge.style.display = "none";
      updateTrackUI(t);
    }
    updateGlobalButtons();

    if (metroOn){
      stopMetronome();
      startMetronome();
    }
  }

  bpm.addEventListener("input", onTimingChange);
  tsig.addEventListener("change", onTimingChange);
  [syncModeSel, leadMsEl, extraBeatsSel].forEach(el => el.addEventListener("change", () => {
    for (const t of tracks){
      cancelSchedule(t);
      t.ui.countBadge.style.display = "none";
      updateTrackUI(t);
    }
    updateGlobalButtons();
  }));

  // Init UI
  buildUI();
  buildBeatLeds();
  bpmVal.textContent = bpm.value;
  if (mfBpm) mfBpm.textContent = bpm.value;
  if (mfSig) mfSig.textContent = tsig.value + "/4";
  updateTimingBadges();
  srEl.textContent = "—";
  setInterval(() => setDots(), 500);
})();
</script>
</body>
</html>
