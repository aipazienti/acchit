<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MaracaDJ Pro ‚Äî 4-Deck System</title>
<style>
:root {
  --bg: #111;
  --deck-bg: #1e1e1e;
  --panel: #252525;
  --accent: #00ffcc;
  --accent2: #ff8c00;
  --master: #ffd700;
  --danger: #ff3333;
  --blue: #2196F3;
  --text: #eee;
  --dim: #888;
  --border: #3a3a3a;
}
* { box-sizing: border-box; }
body {
  font-family: 'Segoe UI', sans-serif;
  background: var(--bg);
  color: var(--text);
  margin: 0;
  padding: 10px;
  min-height: 100vh;
}
h1 {
  text-align: center;
  text-transform: uppercase;
  letter-spacing: 3px;
  color: var(--accent);
  margin: 5px 0 15px;
  font-size: 1.2rem;
}
.console-container {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 10px;
  max-width: 1600px;
  margin: 0 auto;
}

/* === DECK === */
.deck {
  background: var(--deck-bg);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 10px;
  display: flex;
  flex-direction: column;
  gap: 6px;
  position: relative;
}
.deck.active { border-color: var(--accent); box-shadow: 0 0 8px #00ffcc44; }
.deck.master-deck { border-color: var(--master) !important; box-shadow: 0 0 12px #ffd70066 !important; }

.deck-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid var(--border);
  padding-bottom: 6px;
  gap: 4px;
  flex-wrap: wrap;
}
.deck-title { font-weight: bold; color: var(--accent); font-size: 0.95rem; }
.master-badge {
  background: var(--master);
  color: #000;
  font-size: 0.6rem;
  font-weight: bold;
  padding: 2px 5px;
  border-radius: 3px;
  display: none;
}
.deck.master-deck .master-badge { display: inline; }

.bpm-section {
  display: flex;
  align-items: center;
  gap: 4px;
}
.bpm-display {
  font-family: 'Courier New', monospace;
  font-size: 1.3rem;
  background: #000;
  color: var(--accent);
  padding: 3px 8px;
  border-radius: 4px;
  border: 1px solid #333;
  cursor: pointer;
  min-width: 58px;
  text-align: center;
}
.bpm-display:hover { border-color: var(--accent); }

.track-name {
  font-size: 0.75rem;
  color: #ccc;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  height: 18px;
}

/* === WAVEFORM CANVAS === */
.waveform-wrapper {
  position: relative;
  width: 100%;
  height: 80px;
  background: #000;
  border-radius: 4px;
  overflow: hidden;
  cursor: crosshair;
  border: 1px solid #333;
}
.waveform-canvas {
  width: 100%;
  height: 100%;
  display: block;
}
.playhead {
  position: absolute;
  top: 0;
  width: 2px;
  height: 100%;
  background: var(--accent);
  pointer-events: none;
  box-shadow: 0 0 4px var(--accent);
}
/* Beat markers overlay */
.beat-canvas {
  position: absolute;
  top: 0; left: 0;
  width: 100%; height: 100%;
  pointer-events: none;
}

/* === TIME DISPLAY === */
.time-row {
  display: flex;
  justify-content: space-between;
  font-family: 'Courier New', monospace;
  font-size: 0.8rem;
  padding: 2px 4px;
  background: #000;
  border-radius: 4px;
}
.time-elapsed { color: var(--accent); }
.time-remaining { color: var(--accent2); }
.time-total { color: var(--dim); }

/* === CONTROLS === */
.controls {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 5px;
}
button {
  padding: 7px 5px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-weight: bold;
  font-size: 0.72rem;
  text-transform: uppercase;
  transition: 0.15s;
  letter-spacing: 0.5px;
}
button:active { transform: scale(0.97); }
.btn-play { background: #4CAF50; color: #fff; }
.btn-stop { background: var(--danger); color: #fff; }
.btn-sync { background: var(--blue); color: #fff; }
.btn-master { background: var(--master); color: #000; }
.btn-cue { background: #9C27B0; color: #fff; }
.btn-loop { background: #FF9800; color: #000; }
.btn-hot { background: #e91e63; color: #fff; font-size: 0.65rem; }

.ctrl-row {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr 1fr;
  gap: 4px;
}

/* === SLIDERS === */
.slider-group {
  display: flex;
  flex-direction: column;
  gap: 2px;
}
label { font-size: 0.72rem; color: var(--dim); }
input[type=range] { width: 100%; cursor: pointer; accent-color: var(--accent); }
input[type=range].orange { accent-color: var(--accent2); }
input[type=range].yellow { accent-color: var(--master); }

/* Key display */
.key-row {
  display: flex;
  gap: 5px;
  align-items: center;
  flex-wrap: wrap;
}
.key-badge {
  background: #000;
  border: 1px solid #444;
  border-radius: 3px;
  padding: 2px 6px;
  font-size: 0.72rem;
  color: #aaa;
  min-width: 38px;
  text-align: center;
}
.key-badge.detected { color: var(--accent); border-color: var(--accent); }
.key-lock-btn {
  background: #333;
  color: var(--dim);
  border: 1px solid #444;
  font-size: 0.65rem;
  padding: 2px 6px;
  border-radius: 3px;
  cursor: pointer;
}
.key-lock-btn.locked { background: #1a4a1a; color: #4CAF50; border-color: #4CAF50; }

/* === POPUP MODAL === */
.popup-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: #000a;
  z-index: 1000;
  align-items: center;
  justify-content: center;
}
.popup-overlay.open { display: flex; }
.popup {
  background: #222;
  border: 1px solid var(--accent);
  border-radius: 10px;
  padding: 20px;
  min-width: 320px;
  max-width: 420px;
  position: relative;
  box-shadow: 0 0 30px #00ffcc44;
}
.popup h3 { margin: 0 0 15px; color: var(--accent); }
.popup label { color: var(--dim); font-size: 0.8rem; }
.popup input[type=number], .popup input[type=range], .popup select {
  width: 100%;
  margin: 4px 0 12px;
  padding: 5px;
  background: #111;
  color: var(--text);
  border: 1px solid #444;
  border-radius: 4px;
}
.popup-close {
  position: absolute;
  top: 10px; right: 12px;
  background: none;
  border: none;
  color: var(--dim);
  font-size: 1.2rem;
  cursor: pointer;
  padding: 0;
}
.popup-close:hover { color: var(--danger); }
.popup-actions {
  display: flex;
  gap: 8px;
  justify-content: flex-end;
  margin-top: 10px;
}
.popup-actions button { padding: 8px 16px; }
.btn-confirm { background: var(--accent); color: #000; }
.btn-cancel { background: #444; color: #fff; }

/* === BEAT GRID EDITOR (inside popup) === */
.beat-offset-display {
  font-family: 'Courier New', monospace;
  font-size: 1.1rem;
  text-align: center;
  color: var(--accent);
  background: #000;
  padding: 8px;
  border-radius: 4px;
  margin: 8px 0;
}

/* === MIXER === */
.mixer-section {
  grid-column: 1 / -1;
  background: var(--panel);
  padding: 12px 20px;
  border-radius: 8px;
  margin-top: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 20px;
  flex-wrap: wrap;
  border: 1px solid var(--border);
}
.mixer-label { font-size: 0.75rem; color: var(--dim); text-transform: uppercase; }

/* file input */
input[type="file"] {
  font-size: 0.72rem;
  color: #aaa;
  width: 100%;
}

/* Hotcues row */
.hotcues { display: flex; gap: 3px; flex-wrap: wrap; }
.hotcue-btn {
  width: 28px; height: 20px;
  font-size: 0.6rem;
  border-radius: 3px;
  padding: 0;
}

/* EQ row */
.eq-row {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap: 4px;
}

@media (max-width: 1100px) { .console-container { grid-template-columns: 1fr 1fr; } }
@media (max-width: 600px) { .console-container { grid-template-columns: 1fr; } }
</style>
</head>
<body>

<h1>üéõ MaracaDJ Pro <span style="font-size:0.6em;color:#555">4-Deck System</span></h1>

<div class="console-container" id="console">
  <!-- Decks generati da JS -->
</div>

<!-- POPUP BPM EDIT -->
<div class="popup-overlay" id="popup-bpm">
  <div class="popup">
    <button class="popup-close" onclick="closePopup('popup-bpm')">‚úï</button>
    <h3>üéµ Modifica BPM</h3>
    <label>BPM rilevato / manuale:</label>
    <input type="number" id="popup-bpm-val" min="40" max="300" step="0.1">
    <label>Regolazione beat offset (ms):</label>
    <div class="beat-offset-display" id="popup-beat-offset-display">0 ms</div>
    <input type="range" id="popup-beat-offset" min="-500" max="500" step="1" value="0" oninput="updateBeatOffsetDisplay(this.value)">
    <div class="popup-actions">
      <button class="btn-cancel" onclick="closePopup('popup-bpm')">Annulla</button>
      <button class="btn-confirm" onclick="confirmBPM()">Applica</button>
    </div>
  </div>
</div>

<!-- POPUP KEY/PITCH EDIT -->
<div class="popup-overlay" id="popup-key">
  <div class="popup">
    <button class="popup-close" onclick="closePopup('popup-key')">‚úï</button>
    <h3>üéº Tonalit√† & Pitch</h3>
    <label>Key Lock (mantieni tonalit√† se cambi velocit√†):</label>
    <select id="popup-keylock">
      <option value="0">OFF ‚Äî velocit√† e pitch insieme</option>
      <option value="1">ON ‚Äî mantieni tonalit√† originale</option>
    </select>
    <label>Trasposizione tonalit√† (semitoni):</label>
    <div style="display:flex;gap:8px;align-items:center;margin:4px 0 12px">
      <button onclick="adjSemitone(-1)" style="padding:5px 12px;background:#333;color:#fff;border:none;border-radius:4px;cursor:pointer">-1</button>
      <div id="popup-semitone-display" style="flex:1;text-align:center;font-family:monospace;font-size:1.2rem;color:var(--accent);background:#000;border-radius:4px;padding:5px">0 st</div>
      <button onclick="adjSemitone(+1)" style="padding:5px 12px;background:#333;color:#fff;border:none;border-radius:4px;cursor:pointer">+1</button>
    </div>
    <label>Aggiustamento cents (¬±100¬¢ = 1 semitono):</label>
    <div style="display:flex;align-items:center;gap:6px;margin:4px 0 12px">
      <input type="range" id="popup-cents" min="-100" max="100" step="1" value="0" oninput="updateCentsDisplay(this.value)" style="flex:1">
      <span id="popup-cents-display" style="font-family:monospace;color:var(--accent2);min-width:50px;text-align:right">0 ¬¢</span>
    </div>
    <label>Tonalit√† rilevata:</label>
    <div id="popup-key-original" style="font-family:monospace;color:var(--accent);background:#000;padding:6px;border-radius:4px;margin-bottom:12px;text-align:center">‚Äî</div>
    <label>Tonalit√† risultante:</label>
    <div id="popup-key-result" style="font-family:monospace;color:var(--accent2);background:#000;padding:6px;border-radius:4px;margin-bottom:12px;text-align:center">‚Äî</div>
    <div class="popup-actions">
      <button class="btn-cancel" onclick="resetKey()">Reset</button>
      <button class="btn-confirm" onclick="confirmKey()">Applica</button>
    </div>
  </div>
</div>

<!-- POPUP BEAT MANUAL OFFSET -->
<div class="popup-overlay" id="popup-beat">
  <div class="popup">
    <button class="popup-close" onclick="closePopup('popup-beat')">‚úï</button>
    <h3>ü•Å Spostamento Beat Manuale</h3>
    <p style="font-size:0.8rem;color:var(--dim)">Clicca sulla forma d'onda per impostare il primo beat, oppure usa i controlli sotto.</p>
    <label>Offset primo beat (ms):</label>
    <div class="beat-offset-display" id="popup-manual-beat-display">0 ms</div>
    <input type="range" id="popup-manual-beat" min="-2000" max="2000" step="10" value="0" oninput="updateManualBeatDisplay(this.value)">
    <label>Nudge (sposta beat ¬±10ms):</label>
    <div style="display:flex;gap:8px;margin:6px 0">
      <button onclick="nudgeBeat(-100)" style="flex:1;background:#333;color:#fff;border:none;border-radius:4px;padding:6px;cursor:pointer">‚óÄ‚óÄ -100ms</button>
      <button onclick="nudgeBeat(-10)" style="flex:1;background:#333;color:#fff;border:none;border-radius:4px;padding:6px;cursor:pointer">‚óÄ -10ms</button>
      <button onclick="nudgeBeat(10)" style="flex:1;background:#333;color:#fff;border:none;border-radius:4px;padding:6px;cursor:pointer">+10ms ‚ñ∂</button>
      <button onclick="nudgeBeat(100)" style="flex:1;background:#333;color:#fff;border:none;border-radius:4px;padding:6px;cursor:pointer">+100ms ‚ñ∂‚ñ∂</button>
    </div>
    <div class="popup-actions">
      <button class="btn-cancel" onclick="closePopup('popup-beat')">Chiudi</button>
      <button class="btn-confirm" onclick="confirmBeat()">Applica</button>
    </div>
  </div>
</div>

<script>
// =================== AUDIO CONTEXT ===================
const AudioContext = window.AudioContext || window.webkitAudioContext;
const ctx = new AudioContext();
const masterGain = ctx.createGain();
masterGain.gain.value = 0.8;
masterGain.connect(ctx.destination);

let masterDeckIndex = 0; // chi √® il master

const NOTE_NAMES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];

// =================== DECK STATE ===================
const decks = Array.from({length: 4}, (_, i) => ({
  buffer: null, source: null,
  gainNode: null, analyserNode: null,
  eqLow: null, eqMid: null, eqHigh: null,
  pitchNode: null,
  bpm: 0, originalBpm: 0,
  isPlaying: false,
  speed: 1.0,
  keyLock: false,
  semitones: 0,
  cents: 0,
  beatOffset: 0,       // ms offset for beat grid
  startTime: 0,        // AudioContext time when playback started
  pausePosition: 0,    // position in buffer when paused
  duration: 0,
  waveformData: null,
  beats: [],           // detected beat positions in seconds
  hotcues: [null, null, null, null, null, null, null, null],
  loopStart: null, loopEnd: null, loopActive: false,
  detectedKey: null,
  animFrame: null
}));

let popupDeck = 0;

// =================== BUILD UI ===================
const DECK_NAMES = ['A','B','C','D'];
const colors = ['#00ffcc','#ff8c00','#e040fb','#40c4ff'];

function buildDecks() {
  const container = document.getElementById('console');
  DECK_NAMES.forEach((name, i) => {
    container.innerHTML += `
    <div class="deck" id="deck-${i}">
      <div class="deck-header">
        <span class="deck-title" style="color:${colors[i]}">DECK ${name}</span>
        <span class="master-badge" id="master-badge-${i}">‚òÖ MASTER</span>
        <div class="bpm-section">
          <span class="bpm-display" id="bpm-${i}" title="Click per modificare BPM" onclick="openBpmPopup(${i})">--</span>
          <button class="btn-master" id="btn-master-${i}" onclick="setMasterDeck(${i})" style="font-size:0.6rem;padding:3px 6px;${i===0?'':'opacity:0.5'}">M</button>
        </div>
      </div>

      <input type="file" accept="audio/*" onchange="loadTrack(${i}, this)">
      <div class="track-name" id="track-name-${i}">Nessuna traccia</div>

      <!-- WAVEFORM -->
      <div class="waveform-wrapper" id="wf-wrap-${i}" onclick="seekByClick(${i}, event)">
        <canvas class="waveform-canvas" id="wf-${i}"></canvas>
        <canvas class="beat-canvas" id="beatcanvas-${i}"></canvas>
        <div class="playhead" id="playhead-${i}" style="left:0%"></div>
      </div>

      <!-- TIME ROW -->
      <div class="time-row">
        <span class="time-elapsed" id="time-elapsed-${i}">0:00.0</span>
        <span class="time-total" id="time-total-${i}">0:00</span>
        <span class="time-remaining" id="time-remaining-${i}">-0:00.0</span>
      </div>

      <!-- CONTROLS -->
      <div class="controls">
        <button class="btn-play" onclick="playDeck(${i})" id="btn-play-${i}">‚ñ∂ Play</button>
        <button class="btn-stop" onclick="stopDeck(${i})">‚ñ† Stop</button>
        <button class="btn-cue" onclick="setCue(${i})">CUE</button>
        <button class="btn-sync" onclick="syncDeck(${i})">SYNC</button>
      </div>

      <div class="ctrl-row">
        <button class="btn-loop" onclick="toggleLoop(${i})" id="btn-loop-${i}" style="grid-column:span 2">LOOP</button>
        <button onclick="openBeatPopup(${i})" style="background:#333;color:#aaa;font-size:0.65rem;">BEAT</button>
        <button onclick="openKeyPopup(${i})" style="background:#333;color:#aaa;font-size:0.65rem;" id="btn-key-${i}">KEY</button>
      </div>

      <!-- HOTCUES -->
      <div class="hotcues" id="hotcues-${i}">
        ${Array.from({length:8},(_,h)=>`<button class="hotcue-btn btn-hot" onclick="hotcueAction(${i},${h})" id="hc-${i}-${h}" title="HotCue ${h+1}">${h+1}</button>`).join('')}
      </div>

      <!-- KEY display -->
      <div class="key-row">
        <span class="key-badge" id="key-detected-${i}">‚Äî</span>
        <span class="key-badge" id="key-result-${i}" style="color:var(--accent2)">‚Äî</span>
        <button class="key-lock-btn" id="keylock-btn-${i}" onclick="toggleKeyLock(${i})">üîì LOCK</button>
      </div>

      <!-- SPEED / PITCH -->
      <div class="slider-group">
        <label>Velocit√† BPM (<span id="rate-val-${i}">1.00</span>x ‚Äî <span id="bpm-live-${i}" style="color:${colors[i]}">--</span> BPM)</label>
        <input type="range" class="orange" min="0.5" max="2.0" step="0.001" value="1" id="speed-slider-${i}" oninput="setSpeed(${i}, this.value)">
      </div>

      <!-- EQ -->
      <div class="eq-row">
        <div class="slider-group">
          <label>LOW <span id="eq-low-val-${i}">0</span>dB</label>
          <input type="range" min="-15" max="6" step="0.5" value="0" oninput="setEQ(${i},'low',this.value)">
        </div>
        <div class="slider-group">
          <label>MID <span id="eq-mid-val-${i}">0</span>dB</label>
          <input type="range" min="-15" max="6" step="0.5" value="0" oninput="setEQ(${i},'mid',this.value)">
        </div>
        <div class="slider-group">
          <label>HIGH <span id="eq-high-val-${i}">0</span>dB</label>
          <input type="range" min="-15" max="6" step="0.5" value="0" oninput="setEQ(${i},'high',this.value)">
        </div>
      </div>

      <!-- VOLUME -->
      <div class="slider-group">
        <label>Volume</label>
        <input type="range" class="yellow" min="0" max="1" step="0.01" value="1" oninput="setVolume(${i}, this.value)">
      </div>
    </div>`;
  });

  // Mixer
  container.innerHTML += `
  <div class="mixer-section">
    <div>
      <div class="mixer-label">Master Vol</div>
      <input type="range" min="0" max="1" step="0.01" value="0.8" oninput="setMasterVolume(this.value)" style="width:120px;accent-color:var(--master)">
    </div>
    <div style="flex:1;max-width:500px">
      <div class="mixer-label" style="text-align:center">Crossfader A ‚Üê‚Üí B</div>
      <input type="range" min="0" max="1" step="0.01" value="0.5" oninput="setCrossfader(this.value)" style="width:100%;accent-color:var(--accent)">
    </div>
  </div>`;

  // Init audio nodes
  decks.forEach((d, i) => {
    d.gainNode = ctx.createGain();
    d.analyserNode = ctx.createAnalyser();
    d.eqLow = ctx.createBiquadFilter(); d.eqLow.type = 'lowshelf'; d.eqLow.frequency.value = 200;
    d.eqMid = ctx.createBiquadFilter(); d.eqMid.type = 'peaking'; d.eqMid.frequency.value = 1000; d.eqMid.Q.value = 0.5;
    d.eqHigh = ctx.createBiquadFilter(); d.eqHigh.type = 'highshelf'; d.eqHigh.frequency.value = 6000;
    // chain: gain ‚Üí eq ‚Üí analyser ‚Üí master
    d.gainNode.connect(d.eqLow);
    d.eqLow.connect(d.eqMid);
    d.eqMid.connect(d.eqHigh);
    d.eqHigh.connect(d.analyserNode);
    d.analyserNode.connect(masterGain);
  });
  updateMasterUI();
}
buildDecks();

// =================== MASTER ===================
function setMasterDeck(index) {
  masterDeckIndex = index;
  updateMasterUI();
}
function updateMasterUI() {
  decks.forEach((_, i) => {
    document.getElementById(`deck-${i}`).classList.toggle('master-deck', i === masterDeckIndex);
    document.getElementById(`master-badge-${i}`).style.display = i === masterDeckIndex ? 'inline' : 'none';
    document.getElementById(`btn-master-${i}`).style.opacity = i === masterDeckIndex ? '1' : '0.4';
  });
  // Update all sync buttons
  DECK_NAMES.forEach((_, i) => {
    const btn = document.querySelector(`#deck-${i} .btn-sync`);
    if (btn) btn.title = `Sync al Master (Deck ${DECK_NAMES[masterDeckIndex]})`;
  });
}

// =================== LOAD TRACK ===================
async function loadTrack(deckIndex, inputElement) {
  const file = inputElement.files[0];
  if (!file) return;
  if (ctx.state === 'suspended') ctx.resume();
  document.getElementById(`track-name-${deckIndex}`).innerText = file.name;
  document.getElementById(`deck-${deckIndex}`).classList.add('active');

  const arrBuf = await file.arrayBuffer();
  ctx.decodeAudioData(arrBuf, (buffer) => {
    const d = decks[deckIndex];
    d.buffer = buffer;
    d.duration = buffer.duration;
    d.pausePosition = 0;
    d.hotcues = [null,null,null,null,null,null,null,null];
    d.loopStart = null; d.loopEnd = null; d.loopActive = false;
    document.getElementById(`time-total-${deckIndex}`).textContent = formatTime(buffer.duration);
    
    // BPM
    const bpm = detectBPM(buffer);
    d.bpm = bpm; d.originalBpm = bpm;
    document.getElementById(`bpm-${deckIndex}`).innerText = bpm.toFixed(1);
    document.getElementById(`bpm-live-${deckIndex}`).innerText = (bpm * d.speed).toFixed(1);
    
    // Detect beats
    d.beats = detectBeats(buffer, bpm, d.beatOffset);
    
    // Key detection (simplified)
    d.detectedKey = detectKey(buffer);
    updateKeyDisplay(deckIndex);
    
    // Draw waveform
    buildWaveform(deckIndex, buffer);
    drawBeatMarkers(deckIndex);
  }, (e) => { console.error("Decode error", e); alert("Errore nella decodifica audio."); });
}

// =================== WAVEFORM ===================
function buildWaveform(deckIndex, buffer) {
  const canvas = document.getElementById(`wf-${deckIndex}`);
  const wrap = document.getElementById(`wf-wrap-${deckIndex}`);
  canvas.width = wrap.offsetWidth || 300;
  canvas.height = 80;
  const c = canvas.getContext('2d');
  
  const data = buffer.getChannelData(0);
  const w = canvas.width, h = canvas.height;
  const step = Math.ceil(data.length / w);
  const color = colors[deckIndex];
  
  c.clearRect(0, 0, w, h);
  
  // Background gradient
  const grad = c.createLinearGradient(0, 0, 0, h);
  grad.addColorStop(0, '#111');
  grad.addColorStop(0.5, '#1a1a1a');
  grad.addColorStop(1, '#111');
  c.fillStyle = grad;
  c.fillRect(0, 0, w, h);
  
  // Center line
  c.strokeStyle = '#333';
  c.lineWidth = 1;
  c.beginPath(); c.moveTo(0, h/2); c.lineTo(w, h/2); c.stroke();
  
  // Waveform
  const halfH = h / 2;
  for (let x = 0; x < w; x++) {
    let min = 1, max = -1;
    for (let s = 0; s < step; s++) {
      const v = data[x * step + s] || 0;
      if (v < min) min = v;
      if (v > max) max = v;
    }
    const amp = Math.abs(max - min);
    
    // Color by amplitude
    const bright = Math.min(1, amp * 3);
    const r = parseInt(color.slice(1,3), 16);
    const g = parseInt(color.slice(3,5), 16);
    const b = parseInt(color.slice(5,7), 16);
    c.fillStyle = `rgba(${r},${g},${b},${0.3 + bright * 0.7})`;
    
    const topY = halfH - max * halfH;
    const botY = halfH - min * halfH;
    c.fillRect(x, topY, 1, Math.max(1, botY - topY));
  }
  
  // Save for later reference
  decks[deckIndex].waveformData = c.getImageData(0, 0, w, h);
}

function drawBeatMarkers(deckIndex) {
  const d = decks[deckIndex];
  if (!d.buffer) return;
  const canvas = document.getElementById(`beatcanvas-${deckIndex}`);
  const wrap = document.getElementById(`wf-wrap-${deckIndex}`);
  canvas.width = wrap.offsetWidth || 300;
  canvas.height = 80;
  const c = canvas.getContext('2d');
  c.clearRect(0, 0, canvas.width, canvas.height);
  
  const w = canvas.width;
  const duration = d.buffer.duration;
  
  d.beats.forEach((beatTime, bi) => {
    const x = (beatTime / duration) * w;
    const isMeasure = bi % 4 === 0;
    c.strokeStyle = isMeasure ? 'rgba(255,255,100,0.8)' : 'rgba(255,255,255,0.3)';
    c.lineWidth = isMeasure ? 1.5 : 0.8;
    c.beginPath(); c.moveTo(x, isMeasure ? 0 : 20); c.lineTo(x, isMeasure ? 80 : 60); c.stroke();
    
    if (isMeasure && bi % 16 === 0) {
      c.fillStyle = 'rgba(255,255,100,0.6)';
      c.font = '8px monospace';
      c.fillText(Math.floor(bi/4)+1, x+2, 10);
    }
  });
  
  // Hotcues
  d.hotcues.forEach((pos, hi) => {
    if (pos === null) return;
    const x = (pos / duration) * w;
    const hcColors = ['#ff5555','#ffaa00','#ffff00','#55ff55','#55ffff','#5555ff','#ff55ff','#ff9955'];
    c.strokeStyle = hcColors[hi];
    c.lineWidth = 2;
    c.beginPath(); c.moveTo(x, 0); c.lineTo(x, 80); c.stroke();
    c.fillStyle = hcColors[hi];
    c.font = 'bold 9px monospace';
    c.fillText(hi+1, x+2, 20);
  });
}

// =================== DETECT BEATS ===================
function detectBeats(buffer, bpm, offsetMs) {
  const sampleRate = buffer.sampleRate;
  const secondsPerBeat = 60 / bpm;
  const offsetSec = (offsetMs || 0) / 1000;
  const duration = buffer.duration;
  const beats = [];
  let t = offsetSec;
  if (t < 0) t += secondsPerBeat * Math.ceil(-t / secondsPerBeat);
  while (t < duration) {
    beats.push(t);
    t += secondsPerBeat;
  }
  return beats;
}

// =================== PLAYBACK ===================
function getCurrentPosition(deckIndex) {
  const d = decks[deckIndex];
  if (!d.isPlaying) return d.pausePosition;
  return d.pausePosition + (ctx.currentTime - d.startTime) * d.speed;
}

function playDeck(index) {
  if (!decks[index].buffer) { alert("Carica prima una traccia!"); return; }
  if (ctx.state === 'suspended') ctx.resume();
  const d = decks[index];
  
  if (d.source) { try { d.source.stop(); } catch(e){} d.source = null; }
  
  const source = ctx.createBufferSource();
  source.buffer = d.buffer;
  source.playbackRate.value = computePlaybackRate(index);
  if (d.loopActive && d.loopStart !== null && d.loopEnd !== null) {
    source.loop = true;
    source.loopStart = d.loopStart;
    source.loopEnd = d.loopEnd;
  } else {
    source.loop = false;
  }
  source.connect(d.gainNode);
  
  const offset = Math.max(0, Math.min(d.pausePosition, d.buffer.duration - 0.01));
  source.start(0, offset);
  d.source = source;
  d.startTime = ctx.currentTime;
  d.isPlaying = true;
  
  document.getElementById(`btn-play-${index}`).textContent = '‚ùö‚ùö Pause';
  document.getElementById(`btn-play-${index}`).onclick = () => pauseDeck(index);
  
  if (d.animFrame) cancelAnimationFrame(d.animFrame);
  animateDeck(index);
}

function pauseDeck(index) {
  const d = decks[index];
  d.pausePosition = getCurrentPosition(index);
  if (d.source) { try { d.source.stop(); } catch(e){} d.source = null; }
  d.isPlaying = false;
  document.getElementById(`btn-play-${index}`).textContent = '‚ñ∂ Play';
  document.getElementById(`btn-play-${index}`).onclick = () => playDeck(index);
}

function stopDeck(index) {
  const d = decks[index];
  if (d.source) { try { d.source.stop(); } catch(e){} d.source = null; }
  d.isPlaying = false;
  d.pausePosition = 0;
  document.getElementById(`btn-play-${index}`).textContent = '‚ñ∂ Play';
  document.getElementById(`btn-play-${index}`).onclick = () => playDeck(index);
  document.getElementById(`playhead-${index}`).style.left = '0%';
  document.getElementById(`time-elapsed-${index}`).textContent = '0:00.0';
  document.getElementById(`time-remaining-${index}`).textContent = '-' + formatTime(d.duration);
  if (d.animFrame) cancelAnimationFrame(d.animFrame);
}

function animateDeck(index) {
  const d = decks[index];
  if (!d.isPlaying) return;
  
  const pos = getCurrentPosition(index);
  const dur = d.buffer ? d.buffer.duration : 1;
  const pct = Math.min(1, pos / dur);
  
  document.getElementById(`playhead-${index}`).style.left = (pct * 100) + '%';
  document.getElementById(`time-elapsed-${index}`).textContent = formatTimeSub(pos);
  document.getElementById(`time-remaining-${index}`).textContent = '-' + formatTimeSub(dur - pos);
  
  d.animFrame = requestAnimationFrame(() => animateDeck(index));
}

function formatTime(s) {
  const m = Math.floor(s / 60);
  const ss = Math.floor(s % 60);
  return `${m}:${ss.toString().padStart(2,'0')}`;
}
function formatTimeSub(s) {
  if (s < 0) s = 0;
  const m = Math.floor(s / 60);
  const ss = (s % 60).toFixed(1);
  return `${m}:${ss.padStart(4,'0')}`;
}

function seekByClick(index, event) {
  const d = decks[index];
  if (!d.buffer) return;
  const wrap = document.getElementById(`wf-wrap-${index}`);
  const rect = wrap.getBoundingClientRect();
  const pct = (event.clientX - rect.left) / rect.width;
  const newPos = pct * d.buffer.duration;
  d.pausePosition = Math.max(0, Math.min(newPos, d.buffer.duration - 0.01));
  if (d.isPlaying) {
    playDeck(index);
  } else {
    document.getElementById(`playhead-${index}`).style.left = (pct*100)+'%';
    document.getElementById(`time-elapsed-${index}`).textContent = formatTimeSub(d.pausePosition);
    document.getElementById(`time-remaining-${index}`).textContent = '-' + formatTimeSub(d.buffer.duration - d.pausePosition);
  }
}

// =================== CUE / LOOP / HOTCUE ===================
function setCue(index) {
  const d = decks[index];
  d.pausePosition = getCurrentPosition(index);
  if (d.isPlaying) pauseDeck(index);
}

function toggleLoop(index) {
  const d = decks[index];
  if (!d.isPlaying && !d.loopActive) {
    // Set loop start
    d.loopStart = getCurrentPosition(index);
    d.loopEnd = d.loopStart + (60 / (d.bpm || 120)) * 4; // 4 beats
    d.loopActive = true;
  } else if (d.loopActive) {
    d.loopActive = false;
    if (d.source) d.source.loop = false;
  } else {
    d.loopStart = getCurrentPosition(index);
    d.loopEnd = d.loopStart + (60 / (d.bpm || 120)) * 4;
    d.loopActive = true;
  }
  document.getElementById(`btn-loop-${index}`).style.background = d.loopActive ? '#e65100' : '#FF9800';
  document.getElementById(`btn-loop-${index}`).textContent = d.loopActive ? 'üîÅ LOOP ON' : 'LOOP';
  if (d.isPlaying) playDeck(index);
}

function hotcueAction(deckIndex, slot) {
  const d = decks[deckIndex];
  const pos = getCurrentPosition(deckIndex);
  
  if (d.hotcues[slot] === null) {
    // Set hotcue
    d.hotcues[slot] = pos;
    document.getElementById(`hc-${deckIndex}-${slot}`).style.opacity = '1';
    document.getElementById(`hc-${deckIndex}-${slot}`).style.boxShadow = '0 0 5px #e91e63';
  } else {
    // Jump to hotcue
    d.pausePosition = d.hotcues[slot];
    if (d.isPlaying) playDeck(deckIndex);
    else {
      document.getElementById(`playhead-${deckIndex}`).style.left = (d.hotcues[slot]/d.duration*100)+'%';
    }
  }
  drawBeatMarkers(deckIndex);
}

// Long press hotcue button to delete (right-click)
document.addEventListener('contextmenu', (e) => {
  const btn = e.target.closest('.hotcue-btn');
  if (!btn) return;
  e.preventDefault();
  const id = btn.id; // hc-D-S
  const parts = id.split('-');
  const di = parseInt(parts[1]), slot = parseInt(parts[2]);
  decks[di].hotcues[slot] = null;
  btn.style.opacity = '0.5';
  btn.style.boxShadow = '';
  drawBeatMarkers(di);
});

// =================== SPEED / KEY ===================
function computePlaybackRate(index) {
  const d = decks[index];
  let rate = d.speed;
  if (!d.keyLock) {
    // Also apply pitch (semitones + cents)
    rate *= Math.pow(2, (d.semitones + d.cents/100) / 12);
  }
  return rate;
}

function setSpeed(index, val) {
  const d = decks[index];
  d.speed = parseFloat(val);
  document.getElementById(`rate-val-${index}`).innerText = parseFloat(val).toFixed(3);
  const liveBpm = (d.originalBpm * d.speed);
  document.getElementById(`bpm-live-${index}`).innerText = liveBpm.toFixed(1);
  if (d.source) d.source.playbackRate.value = computePlaybackRate(index);
  updateKeyDisplay(index);
}

function toggleKeyLock(index) {
  const d = decks[index];
  d.keyLock = !d.keyLock;
  const btn = document.getElementById(`keylock-btn-${index}`);
  btn.classList.toggle('locked', d.keyLock);
  btn.textContent = d.keyLock ? 'üîí LOCK' : 'üîì LOCK';
  if (d.source) d.source.playbackRate.value = computePlaybackRate(index);
}

function updateKeyDisplay(index) {
  const d = decks[index];
  const el = document.getElementById(`key-detected-${index}`);
  const el2 = document.getElementById(`key-result-${index}`);
  if (d.detectedKey !== null) {
    el.textContent = NOTE_NAMES[d.detectedKey] + (d.keyLock ? 'üîí' : '');
    el.classList.add('detected');
    const resultKey = ((d.detectedKey + d.semitones) % 12 + 12) % 12;
    el2.textContent = NOTE_NAMES[resultKey] + (d.cents !== 0 ? ` ${d.cents>0?'+':''}${d.cents}¬¢` : '');
  } else {
    el.textContent = '‚Äî'; el2.textContent = '‚Äî';
  }
}

// =================== EQ ===================
function setEQ(index, band, val) {
  const d = decks[index];
  val = parseFloat(val);
  if (band === 'low') { d.eqLow.gain.value = val; document.getElementById(`eq-low-val-${index}`).textContent = val; }
  if (band === 'mid') { d.eqMid.gain.value = val; document.getElementById(`eq-mid-val-${index}`).textContent = val; }
  if (band === 'high') { d.eqHigh.gain.value = val; document.getElementById(`eq-high-val-${index}`).textContent = val; }
}

function setVolume(index, val) {
  decks[index].gainNode.gain.value = val;
}
function setMasterVolume(val) { masterGain.gain.value = val; }

function setCrossfader(val) {
  const volA = Math.cos(val * Math.PI / 2);
  const volB = Math.sin(val * Math.PI / 2);
  if (decks[0].gainNode) decks[0].gainNode.gain.value = volA;
  if (decks[1].gainNode) decks[1].gainNode.gain.value = volB;
}

// =================== SYNC ===================
function syncDeck(index) {
  const master = decks[masterDeckIndex];
  const d = decks[index];
  if (index === masterDeckIndex) { alert(`Deck ${DECK_NAMES[index]} √® gi√† il Master.`); return; }
  if (master.bpm === 0 || d.bpm === 0) { alert("BPM non rilevato. Carica le tracce prima."); return; }
  const ratio = (master.bpm * master.speed) / d.originalBpm;
  d.speed = ratio;
  const slider = document.getElementById(`speed-slider-${index}`);
  if (slider) slider.value = ratio;
  document.getElementById(`rate-val-${index}`).innerText = ratio.toFixed(3);
  document.getElementById(`bpm-live-${index}`).innerText = (d.originalBpm * ratio).toFixed(1);
  if (d.source) d.source.playbackRate.value = computePlaybackRate(index);
}

// =================== POPUPS ===================
function openPopup(id) { document.getElementById(id).classList.add('open'); }
function closePopup(id) { document.getElementById(id).classList.remove('open'); }

// --- BPM POPUP ---
function openBpmPopup(index) {
  popupDeck = index;
  document.getElementById('popup-bpm-val').value = decks[index].bpm.toFixed(1);
  document.getElementById('popup-beat-offset').value = decks[index].beatOffset;
  document.getElementById('popup-beat-offset-display').textContent = decks[index].beatOffset + ' ms';
  openPopup('popup-bpm');
}
function updateBeatOffsetDisplay(v) {
  document.getElementById('popup-beat-offset-display').textContent = v + ' ms';
}
function confirmBPM() {
  const d = decks[popupDeck];
  const newBpm = parseFloat(document.getElementById('popup-bpm-val').value);
  const newOffset = parseInt(document.getElementById('popup-beat-offset').value);
  if (newBpm > 0) {
    d.bpm = newBpm; d.originalBpm = newBpm;
    document.getElementById(`bpm-${popupDeck}`).innerText = newBpm.toFixed(1);
    document.getElementById(`bpm-live-${popupDeck}`).innerText = (newBpm * d.speed).toFixed(1);
  }
  d.beatOffset = newOffset;
  if (d.buffer) {
    d.beats = detectBeats(d.buffer, d.bpm, d.beatOffset);
    drawBeatMarkers(popupDeck);
  }
  closePopup('popup-bpm');
}

// --- KEY POPUP ---
let popupSemitones = 0, popupCents = 0;
function openKeyPopup(index) {
  popupDeck = index;
  const d = decks[index];
  popupSemitones = d.semitones;
  popupCents = d.cents;
  document.getElementById('popup-keylock').value = d.keyLock ? '1' : '0';
  document.getElementById('popup-semitone-display').textContent = popupSemitones + ' st';
  document.getElementById('popup-cents').value = popupCents;
  document.getElementById('popup-cents-display').textContent = popupCents + ' ¬¢';
  document.getElementById('popup-key-original').textContent = d.detectedKey !== null ? NOTE_NAMES[d.detectedKey] : '‚Äî';
  updateResultKey();
  openPopup('popup-key');
}
function adjSemitone(delta) {
  popupSemitones = Math.max(-12, Math.min(12, popupSemitones + delta));
  document.getElementById('popup-semitone-display').textContent = popupSemitones + ' st';
  updateResultKey();
}
function updateCentsDisplay(v) {
  popupCents = parseInt(v);
  document.getElementById('popup-cents-display').textContent = v + ' ¬¢';
  updateResultKey();
}
function updateResultKey() {
  const d = decks[popupDeck];
  if (d.detectedKey !== null) {
    const rk = ((d.detectedKey + popupSemitones) % 12 + 12) % 12;
    document.getElementById('popup-key-result').textContent = NOTE_NAMES[rk] + (popupCents !== 0 ? ` ${popupCents>0?'+':''}${popupCents}¬¢` : '');
  }
}
function confirmKey() {
  const d = decks[popupDeck];
  d.keyLock = document.getElementById('popup-keylock').value === '1';
  d.semitones = popupSemitones;
  d.cents = popupCents;
  // Apply pitch shift via playbackRate if not key lock
  if (d.source) d.source.playbackRate.value = computePlaybackRate(popupDeck);
  updateKeyDisplay(popupDeck);
  const btn = document.getElementById(`keylock-btn-${popupDeck}`);
  btn.classList.toggle('locked', d.keyLock);
  btn.textContent = d.keyLock ? 'üîí LOCK' : 'üîì LOCK';
  closePopup('popup-key');
}
function resetKey() {
  popupSemitones = 0; popupCents = 0;
  document.getElementById('popup-semitone-display').textContent = '0 st';
  document.getElementById('popup-cents').value = 0;
  document.getElementById('popup-cents-display').textContent = '0 ¬¢';
  updateResultKey();
}

// --- BEAT POPUP ---
function openBeatPopup(index) {
  popupDeck = index;
  const offset = decks[index].beatOffset;
  document.getElementById('popup-manual-beat').value = offset;
  document.getElementById('popup-manual-beat-display').textContent = offset + ' ms';
  openPopup('popup-beat');
}
function updateManualBeatDisplay(v) {
  document.getElementById('popup-manual-beat-display').textContent = v + ' ms';
}
function nudgeBeat(delta) {
  const slider = document.getElementById('popup-manual-beat');
  const newVal = parseInt(slider.value) + delta;
  slider.value = newVal;
  updateManualBeatDisplay(newVal);
}
function confirmBeat() {
  const d = decks[popupDeck];
  const offset = parseInt(document.getElementById('popup-manual-beat').value);
  d.beatOffset = offset;
  if (d.buffer) {
    d.beats = detectBeats(d.buffer, d.bpm, d.beatOffset);
    drawBeatMarkers(popupDeck);
  }
  closePopup('popup-beat');
}

// =================== BPM DETECTION ===================
function detectBPM(buffer) {
  const data = buffer.getChannelData(0);
  const sampleRate = buffer.sampleRate;
  const step = 512;
  const peaks = [];
  let maxP = 0;
  for (let i = 0; i < data.length - step; i += step) {
    let sum = 0;
    for (let j = 0; j < step; j++) sum += data[i+j] * data[i+j];
    const rms = Math.sqrt(sum / step);
    peaks.push(rms);
    if (rms > maxP) maxP = rms;
  }
  const threshold = maxP * 0.6;
  const beats = [];
  for (let i = 0; i < peaks.length; i++) {
    if (peaks[i] > threshold) {
      if (beats.length === 0 || (i - beats[beats.length-1]) > 8) beats.push(i);
    }
  }
  const intervals = [];
  for (let i = 1; i < beats.length; i++) intervals.push(beats[i] - beats[i-1]);
  
  const bpmMap = {};
  intervals.forEach(iv => {
    if (!iv) return;
    const bpm = Math.round((sampleRate / step) * 60 / iv);
    if (bpm >= 60 && bpm <= 210) bpmMap[bpm] = (bpmMap[bpm]||0) + 1;
  });
  
  // Also check half/double
  let maxC = 0, best = 120;
  for (const b in bpmMap) {
    if (bpmMap[b] > maxC) { maxC = bpmMap[b]; best = parseInt(b); }
  }
  // Range normalization 80-175
  while (best > 175) best /= 2;
  while (best < 80) best *= 2;
  return best > 0 ? best : 120;
}

// =================== KEY DETECTION (simplified chroma) ===================
function detectKey(buffer) {
  try {
    const data = buffer.getChannelData(0);
    const sampleRate = buffer.sampleRate;
    // Sample first 30 seconds max
    const len = Math.min(data.length, sampleRate * 30);
    const chroma = new Float32Array(12);
    const fftSize = 4096;
    
    for (let i = 0; i < len - fftSize; i += fftSize) {
      // Approximate chroma by analyzing frequency bands
      for (let c = 0; c < 12; c++) {
        let energy = 0;
        const freqCenter = 261.63 * Math.pow(2, c/12); // C4 and up
        const binCenter = Math.round(freqCenter * fftSize / sampleRate);
        for (let b = Math.max(0, binCenter-2); b <= Math.min(fftSize/2, binCenter+2); b++) {
          energy += (data[i+b] || 0) ** 2;
        }
        chroma[c] += energy;
      }
    }
    // Find dominant note
    let maxE = 0, key = 0;
    for (let c = 0; c < 12; c++) { if (chroma[c] > maxE) { maxE = chroma[c]; key = c; } }
    return key;
  } catch(e) { return null; }
}

// =================== CLOSE POPUPS ON OVERLAY CLICK ===================
document.querySelectorAll('.popup-overlay').forEach(overlay => {
  overlay.addEventListener('click', (e) => {
    if (e.target === overlay) overlay.classList.remove('open');
  });
});

// =================== RESIZE HANDLER ===================
window.addEventListener('resize', () => {
  decks.forEach((d, i) => {
    if (d.buffer) { buildWaveform(i, d.buffer); drawBeatMarkers(i); }
  });
});
</script>
</body>
</html>
