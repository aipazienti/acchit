<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MaracaDJ Pro v2 ‚Äî 4-Deck System</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Rajdhani:wght@400;600;700&display=swap');
:root {
  --bg: #0a0a0f;
  --deck-bg: #111118;
  --panel: #16161e;
  --accent: #00ffcc;
  --accent2: #ff8c00;
  --master: #ffd700;
  --danger: #ff3333;
  --blue: #2196F3;
  --purple: #b44aff;
  --text: #e8e8f0;
  --dim: #666680;
  --border: #2a2a3a;
  --beat1: rgba(255,220,0,0.95);
  --beat4: rgba(255,255,255,0.4);
}
* { box-sizing: border-box; }
body {
  font-family: 'Rajdhani', 'Segoe UI', sans-serif;
  background: var(--bg);
  color: var(--text);
  margin: 0;
  padding: 10px;
  min-height: 100vh;
  font-weight: 600;
}
h1 {
  text-align: center;
  text-transform: uppercase;
  letter-spacing: 4px;
  color: var(--accent);
  margin: 4px 0 12px;
  font-size: 1.15rem;
  font-family: 'Share Tech Mono', monospace;
}
.console-container {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 8px;
  max-width: 1700px;
  margin: 0 auto;
}
.deck {
  background: var(--deck-bg);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 9px;
  display: flex;
  flex-direction: column;
  gap: 5px;
  position: relative;
}
.deck.active { border-color: var(--accent); box-shadow: 0 0 8px #00ffcc33; }
.deck.master-deck { border-color: var(--master) !important; box-shadow: 0 0 14px #ffd70055 !important; }

.deck-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid var(--border);
  padding-bottom: 5px;
  gap: 4px;
  flex-wrap: wrap;
}
.deck-title { font-weight: 700; color: var(--accent); font-size: 1rem; font-family: 'Share Tech Mono', monospace; letter-spacing: 2px; }
.master-badge {
  background: var(--master);
  color: #000;
  font-size: 0.58rem;
  font-weight: 700;
  padding: 2px 5px;
  border-radius: 3px;
  display: none;
}
.deck.master-deck .master-badge { display: inline; }
.bpm-section { display: flex; align-items: center; gap: 4px; }
.bpm-display {
  font-family: 'Share Tech Mono', monospace;
  font-size: 1.25rem;
  background: #000;
  color: var(--accent);
  padding: 3px 8px;
  border-radius: 4px;
  border: 1px solid #333;
  cursor: pointer;
  min-width: 60px;
  text-align: center;
  transition: border-color 0.15s;
}
.bpm-display:hover { border-color: var(--accent); }
.bpm-analyzing {
  font-size: 0.6rem;
  color: var(--accent2);
  animation: blink 0.6s infinite;
}
@keyframes blink { 0%,100%{opacity:1} 50%{opacity:0.2} }

.track-name {
  font-size: 0.72rem;
  color: #ccc;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  height: 18px;
}

/* === WAVEFORM === */
.waveform-wrapper {
  position: relative;
  width: 100%;
  height: 90px;
  background: #000;
  border-radius: 4px;
  overflow: hidden;
  border: 1px solid #2a2a3a;
  user-select: none;
}
.waveform-canvas {
  position: absolute;
  top: 0; left: 0;
  width: 100%; height: 100%;
  display: block;
}
.beat-canvas {
  position: absolute;
  top: 0; left: 0;
  width: 100%; height: 100%;
  pointer-events: none;
}
.playhead {
  position: absolute;
  top: 0;
  width: 2px;
  height: 100%;
  background: #fff;
  pointer-events: none;
  box-shadow: 0 0 6px #fff, 0 0 2px var(--accent);
  z-index: 5;
  left: 50%;
}
/* Zoom controls */
.zoom-row {
  display: flex;
  gap: 4px;
  align-items: center;
  justify-content: flex-end;
}
.zoom-btn {
  background: #222;
  border: 1px solid #333;
  color: var(--dim);
  font-size: 0.65rem;
  padding: 2px 6px;
  border-radius: 3px;
  cursor: pointer;
  font-family: 'Share Tech Mono', monospace;
}
.zoom-btn:hover { color: var(--accent); border-color: var(--accent); }
.zoom-label { font-size: 0.62rem; color: var(--dim); font-family: monospace; }

/* === TIME === */
.time-row {
  display: flex;
  justify-content: space-between;
  font-family: 'Share Tech Mono', monospace;
  font-size: 0.78rem;
  padding: 2px 4px;
  background: #000;
  border-radius: 4px;
}
.time-elapsed { color: var(--accent); }
.time-remaining { color: var(--accent2); }
.time-total { color: var(--dim); }

/* === CONTROLS === */
.controls {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 5px;
}
button {
  padding: 7px 5px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-weight: 700;
  font-size: 0.72rem;
  text-transform: uppercase;
  transition: 0.12s;
  letter-spacing: 0.5px;
  font-family: 'Rajdhani', sans-serif;
}
button:active { transform: scale(0.96); }
.btn-play { background: #1a7a2a; color: #6fff8e; border: 1px solid #2a9c3a; }
.btn-play:hover { background: #22a038; }
.btn-stop { background: #7a1a1a; color: #ffaaaa; border: 1px solid #9c2a2a; }
.btn-sync { background: #1a3a7a; color: #aac4ff; border: 1px solid #2a5a9c; }
.btn-master { background: var(--master); color: #000; font-size: 0.6rem; }
.btn-cue { background: #4a1a7a; color: #d4aaff; border: 1px solid #6a2a9c; }
.btn-loop { background: #7a4a1a; color: #ffcc88; border: 1px solid #9c6a2a; }
.btn-hot { background: #7a1a3a; color: #ffaac8; font-size: 0.6rem; border: 1px solid #9c2a5a; }
.ctrl-row {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr 1fr;
  gap: 4px;
}
.slider-group { display: flex; flex-direction: column; gap: 2px; }
label { font-size: 0.68rem; color: var(--dim); font-family: 'Rajdhani', sans-serif; }
input[type=range] { width: 100%; cursor: pointer; accent-color: var(--accent); height: 18px; }
input[type=range].orange { accent-color: var(--accent2); }
input[type=range].yellow { accent-color: var(--master); }

.key-row { display: flex; gap: 4px; align-items: center; flex-wrap: wrap; }
.key-badge {
  background: #000;
  border: 1px solid #444;
  border-radius: 3px;
  padding: 2px 6px;
  font-size: 0.7rem;
  color: #888;
  min-width: 36px;
  text-align: center;
  font-family: 'Share Tech Mono', monospace;
}
.key-badge.detected { color: var(--accent); border-color: var(--accent); }
.key-lock-btn {
  background: #1a1a2a;
  color: var(--dim);
  border: 1px solid #333;
  font-size: 0.62rem;
  padding: 2px 6px;
  border-radius: 3px;
  cursor: pointer;
  font-family: 'Rajdhani', sans-serif;
}
.key-lock-btn.locked { background: #0a2a0a; color: #4CAF50; border-color: #4CAF50; }

/* KEY LOCK active indicator on deck */
.keylock-indicator {
  font-size: 0.58rem;
  background: #0a2a0a;
  color: #4CAF50;
  border: 1px solid #4CAF50;
  border-radius: 2px;
  padding: 1px 4px;
  display: none;
}
.keylock-indicator.active { display: inline; }

/* === POPUP === */
.popup-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: #000b;
  z-index: 1000;
  align-items: center;
  justify-content: center;
}
.popup-overlay.open { display: flex; }
.popup {
  background: #181820;
  border: 1px solid var(--accent);
  border-radius: 10px;
  padding: 20px;
  min-width: 340px;
  max-width: 440px;
  position: relative;
  box-shadow: 0 0 40px #00ffcc22;
}
.popup h3 { margin: 0 0 14px; color: var(--accent); font-family: 'Share Tech Mono', monospace; letter-spacing: 2px; font-size: 1rem; }
.popup label { color: var(--dim); font-size: 0.78rem; }
.popup input[type=number], .popup input[type=range], .popup select {
  width: 100%;
  margin: 4px 0 12px;
  padding: 5px;
  background: #0a0a12;
  color: var(--text);
  border: 1px solid #333;
  border-radius: 4px;
  font-family: 'Share Tech Mono', monospace;
}
.popup-close {
  position: absolute;
  top: 10px; right: 12px;
  background: none; border: none;
  color: var(--dim);
  font-size: 1.2rem;
  cursor: pointer; padding: 0;
}
.popup-close:hover { color: var(--danger); }
.popup-actions {
  display: flex; gap: 8px;
  justify-content: flex-end;
  margin-top: 10px;
}
.popup-actions button { padding: 8px 16px; }
.btn-confirm { background: var(--accent); color: #000; font-family: 'Rajdhani', sans-serif; font-weight: 700; }
.btn-cancel { background: #333; color: #fff; font-family: 'Rajdhani', sans-serif; }

.beat-offset-display {
  font-family: 'Share Tech Mono', monospace;
  font-size: 1.1rem;
  text-align: center;
  color: var(--accent);
  background: #000;
  padding: 8px;
  border-radius: 4px;
  margin: 6px 0;
}

/* BPM Analysis display */
.bpm-analysis-box {
  background: #000;
  border: 1px solid #333;
  border-radius: 4px;
  padding: 8px;
  margin: 8px 0;
  font-family: 'Share Tech Mono', monospace;
  font-size: 0.72rem;
  line-height: 1.6;
}
.bpm-candidate { color: #888; cursor: pointer; padding: 2px 4px; border-radius: 2px; }
.bpm-candidate:hover { background: #222; }
.bpm-candidate.best { color: var(--accent); font-weight: bold; }
.bpm-candidate.selected { background: #003322; color: var(--accent); }
.confidence-bar {
  display: inline-block;
  height: 6px;
  border-radius: 2px;
  background: var(--accent);
  opacity: 0.6;
  margin-left: 6px;
  vertical-align: middle;
}

/* === MIXER === */
.mixer-section {
  grid-column: 1 / -1;
  background: var(--panel);
  padding: 10px 20px;
  border-radius: 8px;
  margin-top: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 20px;
  flex-wrap: wrap;
  border: 1px solid var(--border);
}
.mixer-label { font-size: 0.68rem; color: var(--dim); text-transform: uppercase; font-family: 'Rajdhani', sans-serif; }
input[type="file"] { font-size: 0.68rem; color: #999; width: 100%; }
.hotcues { display: flex; gap: 3px; flex-wrap: wrap; }
.hotcue-btn {
  width: 26px; height: 20px;
  font-size: 0.58rem;
  border-radius: 3px;
  padding: 0;
}
.eq-row {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap: 4px;
}

/* Beat grid 1 marker style */
.beat1-glow { text-shadow: 0 0 6px var(--beat1); }

@media (max-width: 1100px) { .console-container { grid-template-columns: 1fr 1fr; } }
@media (max-width: 600px) { .console-container { grid-template-columns: 1fr; } }
</style>
</head>
<body>
<h1>üéõ MaracaDJ Pro <span style="font-size:0.6em;color:#444;font-family:monospace"> v2 ¬∑ 4-Deck</span></h1>
<div class="console-container" id="console"></div>

<!-- POPUP BPM -->
<div class="popup-overlay" id="popup-bpm">
  <div class="popup">
    <button class="popup-close" onclick="closePopup('popup-bpm')">‚úï</button>
    <h3>üéµ BPM & BEAT GRID</h3>
    <label>Analisi BPM approfondita ‚Äî candidati trovati (click per selezionare):</label>
    <div class="bpm-analysis-box" id="bpm-candidates-box">‚Äî</div>
    <label>BPM selezionato / manuale:</label>
    <div style="display:flex;gap:6px;align-items:center;margin:4px 0 12px">
      <input type="number" id="popup-bpm-val" min="40" max="300" step="0.1" oninput="previewBpmChange()" style="flex:1">
      <button onclick="halveBpm()" style="padding:5px 10px;background:#222;color:#aaa;border:1px solid #444;border-radius:4px;cursor:pointer;font-size:0.7rem">√∑2</button>
      <button onclick="doubleBpm()" style="padding:5px 10px;background:#222;color:#aaa;border:1px solid #444;border-radius:4px;cursor:pointer;font-size:0.7rem">√ó2</button>
    </div>
    <label>Beat 1 offset ‚Äî primo beat della griglia (ms):</label>
    <div class="beat-offset-display" id="popup-beat-offset-display">0 ms</div>
    <input type="range" id="popup-beat-offset" min="-2000" max="2000" step="5" value="0" oninput="updateBeatOffsetDisplay(this.value)">
    <div style="display:flex;gap:6px;margin:4px 0 10px">
      <button onclick="nudgeOffset(-10)" style="flex:1;background:#1a1a2a;color:#aaa;border:1px solid #333;border-radius:4px;padding:5px;cursor:pointer;font-size:0.68rem">‚óÄ -10ms</button>
      <button onclick="nudgeOffset(-1)" style="flex:1;background:#1a1a2a;color:#aaa;border:1px solid #333;border-radius:4px;padding:5px;cursor:pointer;font-size:0.68rem">‚óÄ -1ms</button>
      <button onclick="nudgeOffset(1)" style="flex:1;background:#1a1a2a;color:#aaa;border:1px solid #333;border-radius:4px;padding:5px;cursor:pointer;font-size:0.68rem">+1ms ‚ñ∂</button>
      <button onclick="nudgeOffset(10)" style="flex:1;background:#1a1a2a;color:#aaa;border:1px solid #333;border-radius:4px;padding:5px;cursor:pointer;font-size:0.68rem">+10ms ‚ñ∂‚ñ∂</button>
    </div>
    <div class="popup-actions">
      <button class="btn-cancel" onclick="closePopup('popup-bpm')">Annulla</button>
      <button class="btn-confirm" onclick="confirmBPM()">Applica</button>
    </div>
  </div>
</div>

<!-- POPUP KEY/PITCH ‚Äî KEY LOCK corretto -->
<div class="popup-overlay" id="popup-key">
  <div class="popup">
    <button class="popup-close" onclick="closePopup('popup-key')">‚úï</button>
    <h3>üéº TONALIT√Ä & PITCH</h3>
    <div style="background:#001a00;border:1px solid #2a5a2a;border-radius:5px;padding:8px;margin-bottom:12px;font-size:0.72rem;color:#88bb88;font-family:monospace;line-height:1.6">
      üîí KEY LOCK: quando attivo, cambiare la velocit√† NON cambia il pitch.<br>
      La traccia usa time-stretching simulato via buffer-rate separato dal pitch.
    </div>
    <label>Key Lock (mantieni tonalit√† se cambi velocit√†):</label>
    <select id="popup-keylock" style="margin:4px 0 12px">
      <option value="0">OFF ‚Äî velocit√† e pitch cambiano insieme</option>
      <option value="1">ON ‚Äî mantieni tonalit√† originale (time-stretch)</option>
    </select>
    <label>Trasposizione tonalit√† (semitoni):</label>
    <div style="display:flex;gap:8px;align-items:center;margin:4px 0 12px">
      <button onclick="adjSemitone(-1)" style="padding:5px 12px;background:#222;color:#fff;border:1px solid #444;border-radius:4px;cursor:pointer">-1</button>
      <div id="popup-semitone-display" style="flex:1;text-align:center;font-family:monospace;font-size:1.2rem;color:var(--accent);background:#000;border-radius:4px;padding:5px">0 st</div>
      <button onclick="adjSemitone(+1)" style="padding:5px 12px;background:#222;color:#fff;border:1px solid #444;border-radius:4px;cursor:pointer">+1</button>
    </div>
    <label>Fine cents (¬±100¬¢ = 1 semitono):</label>
    <div style="display:flex;align-items:center;gap:6px;margin:4px 0 12px">
      <input type="range" id="popup-cents" min="-100" max="100" step="1" value="0" oninput="updateCentsDisplay(this.value)" style="flex:1">
      <span id="popup-cents-display" style="font-family:monospace;color:var(--accent2);min-width:50px;text-align:right">0 ¬¢</span>
    </div>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:12px">
      <div>
        <div style="font-size:0.68rem;color:var(--dim);margin-bottom:3px">Tonalit√† rilevata</div>
        <div id="popup-key-original" style="font-family:monospace;color:var(--accent);background:#000;padding:6px;border-radius:4px;text-align:center">‚Äî</div>
      </div>
      <div>
        <div style="font-size:0.68rem;color:var(--dim);margin-bottom:3px">Tonalit√† risultante</div>
        <div id="popup-key-result" style="font-family:monospace;color:var(--accent2);background:#000;padding:6px;border-radius:4px;text-align:center">‚Äî</div>
      </div>
    </div>
    <div class="popup-actions">
      <button class="btn-cancel" onclick="resetKey()">Reset</button>
      <button class="btn-confirm" onclick="confirmKey()">Applica</button>
    </div>
  </div>
</div>

<script>
// ===================== AUDIO CONTEXT =====================
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const ctx = new AudioCtx();
const masterGain = ctx.createGain();
masterGain.gain.value = 0.8;
masterGain.connect(ctx.destination);
let masterDeckIndex = 0;
const NOTE_NAMES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
const DECK_NAMES = ['A','B','C','D'];
const colors = ['#00ffcc','#ff8c00','#e040fb','#40c4ff'];
const HCCOLORS = ['#ff5555','#ffaa00','#ffff00','#55ff55','#55ffff','#5555ff','#ff55ff','#ff9955'];

// ===================== DECK STATE =====================
const decks = Array.from({length:4},(_,i) => ({
  buffer: null, source: null,
  gainNode: null, analyserNode: null,
  eqLow: null, eqMid: null, eqHigh: null,
  bpm: 0, originalBpm: 0,
  bpmCandidates: [], // [{bpm, confidence}]
  isPlaying: false,
  speed: 1.0,          // playback rate (tempo)
  pitchShift: 1.0,     // pitch multiplier SEPARATE from speed (for key lock)
  keyLock: false,
  semitones: 0,
  cents: 0,
  beatOffset: 0,
  startTime: 0,
  pausePosition: 0,
  duration: 0,
  waveformPeaks: null, // {min[], max[]} per pixel
  beats: [],
  hotcues: Array(8).fill(null),
  loopStart: null, loopEnd: null, loopActive: false,
  detectedKey: null,
  animFrame: null,
  zoomLevel: 1,        // 1 = full view, >1 = zoomed
  zoomOffset: 0,       // current view start (0..1) as fraction of track
}));

let popupDeck = 0;

// ===================== BUILD UI =====================
function buildDecks() {
  const container = document.getElementById('console');
  DECK_NAMES.forEach((name,i) => {
    const col = colors[i];
    container.innerHTML += `
    <div class="deck" id="deck-${i}">
      <div class="deck-header">
        <span class="deck-title" style="color:${col}">DECK ${name}</span>
        <span class="master-badge" id="master-badge-${i}">‚òÖ MASTER</span>
        <span class="keylock-indicator" id="keylock-ind-${i}">üîíKEY</span>
        <div class="bpm-section">
          <span class="bpm-display" id="bpm-${i}" title="Click per modificare BPM / analisi" onclick="openBpmPopup(${i})">--</span>
          <span class="bpm-analyzing" id="bpm-analyzing-${i}" style="display:none">‚ü≥</span>
          <button class="btn-master" id="btn-master-${i}" onclick="setMasterDeck(${i})" style="font-size:0.58rem;padding:3px 6px;${i===0?'':'opacity:0.45'}">M</button>
        </div>
      </div>

      <input type="file" accept="audio/*" onchange="loadTrack(${i}, this)">
      <div class="track-name" id="track-name-${i}">Nessuna traccia caricata</div>

      <!-- WAVEFORM with zoom -->
      <div class="waveform-wrapper" id="wf-wrap-${i}"
        onmousedown="wfMouseDown(${i},event)"
        onmousemove="wfMouseMove(${i},event)"
        onmouseup="wfMouseUp(${i},event)"
        onmouseleave="wfMouseUp(${i},event)"
        onwheel="wfWheel(${i},event)">
        <canvas class="waveform-canvas" id="wf-${i}"></canvas>
        <canvas class="beat-canvas" id="beatcanvas-${i}"></canvas>
        <div class="playhead" id="playhead-${i}"></div>
      </div>

      <!-- Zoom controls -->
      <div class="zoom-row">
        <span class="zoom-label" id="zoom-label-${i}">ZOOM 1x</span>
        <button class="zoom-btn" onclick="zoomIn(${i})">+ ZOOM</button>
        <button class="zoom-btn" onclick="zoomOut(${i})">- ZOOM</button>
        <button class="zoom-btn" onclick="zoomReset(${i})">FIT</button>
      </div>

      <!-- TIME ROW -->
      <div class="time-row">
        <span class="time-elapsed" id="time-elapsed-${i}">0:00.0</span>
        <span class="time-total" id="time-total-${i}">0:00</span>
        <span class="time-remaining" id="time-remaining-${i}">-0:00.0</span>
      </div>

      <!-- CONTROLS -->
      <div class="controls">
        <button class="btn-play" onclick="playDeck(${i})" id="btn-play-${i}">‚ñ∂ Play</button>
        <button class="btn-stop" onclick="stopDeck(${i})">‚ñ† Stop</button>
        <button class="btn-cue" onclick="setCue(${i})">CUE</button>
        <button class="btn-sync" onclick="syncDeck(${i})">SYNC</button>
      </div>

      <div class="ctrl-row">
        <button class="btn-loop" onclick="toggleLoop(${i})" id="btn-loop-${i}" style="grid-column:span 2">LOOP 4B</button>
        <button onclick="openBpmPopup(${i})" style="background:#1a1a2a;color:#8888aa;border:1px solid #333;font-size:0.62rem;">BPM</button>
        <button onclick="openKeyPopup(${i})" style="background:#1a1a2a;color:#8888aa;border:1px solid #333;font-size:0.62rem;" id="btn-key-${i}">KEY</button>
      </div>

      <!-- HOTCUES -->
      <div class="hotcues" id="hotcues-${i}">
        ${Array.from({length:8},(_,h)=>`<button class="hotcue-btn btn-hot" onclick="hotcueAction(${i},${h})" id="hc-${i}-${h}" title="HotCue ${h+1} ‚Äî right-click to clear">${h+1}</button>`).join('')}
      </div>

      <!-- KEY -->
      <div class="key-row">
        <span class="key-badge" id="key-detected-${i}">‚Äî</span>
        <span class="key-badge" id="key-result-${i}" style="color:var(--accent2)">‚Äî</span>
        <button class="key-lock-btn" id="keylock-btn-${i}" onclick="toggleKeyLock(${i})">üîì LOCK</button>
      </div>

      <!-- SPEED ‚Äî label shows live BPM -->
      <div class="slider-group">
        <label>Velocit√† (<span id="rate-val-${i}">1.000</span>x) ‚Äî BPM live: <span id="bpm-live-${i}" style="color:${col}">--</span></label>
        <input type="range" class="orange" min="0.5" max="2.0" step="0.001" value="1" id="speed-slider-${i}" oninput="setSpeed(${i}, this.value)">
      </div>

      <!-- PITCH (independent of speed when key lock ON) -->
      <div class="slider-group">
        <label>Pitch offset ¬±12st (<span id="pitch-st-val-${i}">0.0</span> st) ‚Äî key lock only</label>
        <input type="range" class="yellow" min="-12" max="12" step="0.01" value="0" id="pitch-slider-${i}" oninput="setPitchSlider(${i}, this.value)">
      </div>

      <!-- EQ -->
      <div class="eq-row">
        <div class="slider-group">
          <label>LOW <span id="eq-low-val-${i}">0</span>dB</label>
          <input type="range" min="-15" max="6" step="0.5" value="0" oninput="setEQ(${i},'low',this.value)">
        </div>
        <div class="slider-group">
          <label>MID <span id="eq-mid-val-${i}">0</span>dB</label>
          <input type="range" min="-15" max="6" step="0.5" value="0" oninput="setEQ(${i},'mid',this.value)">
        </div>
        <div class="slider-group">
          <label>HIGH <span id="eq-high-val-${i}">0</span>dB</label>
          <input type="range" min="-15" max="6" step="0.5" value="0" oninput="setEQ(${i},'high',this.value)">
        </div>
      </div>

      <!-- VOLUME -->
      <div class="slider-group">
        <label>Volume</label>
        <input type="range" min="0" max="1" step="0.01" value="1" oninput="setVolume(${i}, this.value)">
      </div>
    </div>`;
  });

  container.innerHTML += `
  <div class="mixer-section">
    <div>
      <div class="mixer-label">Master Vol</div>
      <input type="range" min="0" max="1" step="0.01" value="0.8" oninput="setMasterVolume(this.value)" style="width:110px;accent-color:var(--master)">
    </div>
    <div style="flex:1;max-width:480px">
      <div class="mixer-label" style="text-align:center">Crossfader A ‚Üê‚Üí B</div>
      <input type="range" min="0" max="1" step="0.01" value="0.5" oninput="setCrossfader(this.value)" style="width:100%;accent-color:var(--accent)">
    </div>
  </div>`;

  decks.forEach((d,i) => {
    d.gainNode = ctx.createGain();
    d.analyserNode = ctx.createAnalyser();
    d.eqLow = ctx.createBiquadFilter(); d.eqLow.type='lowshelf'; d.eqLow.frequency.value=200;
    d.eqMid = ctx.createBiquadFilter(); d.eqMid.type='peaking'; d.eqMid.frequency.value=1000; d.eqMid.Q.value=0.5;
    d.eqHigh = ctx.createBiquadFilter(); d.eqHigh.type='highshelf'; d.eqHigh.frequency.value=6000;
    d.gainNode.connect(d.eqLow);
    d.eqLow.connect(d.eqMid);
    d.eqMid.connect(d.eqHigh);
    d.eqHigh.connect(d.analyserNode);
    d.analyserNode.connect(masterGain);
  });
  updateMasterUI();
}
buildDecks();

// ===================== MASTER =====================
function setMasterDeck(idx) { masterDeckIndex=idx; updateMasterUI(); }
function updateMasterUI() {
  decks.forEach((_,i) => {
    document.getElementById(`deck-${i}`).classList.toggle('master-deck',i===masterDeckIndex);
    document.getElementById(`master-badge-${i}`).style.display = i===masterDeckIndex?'inline':'none';
    document.getElementById(`btn-master-${i}`).style.opacity = i===masterDeckIndex?'1':'0.4';
  });
}

// ===================== LOAD TRACK =====================
async function loadTrack(di, inputEl) {
  const file = inputEl.files[0];
  if(!file) return;
  if(ctx.state==='suspended') ctx.resume();
  document.getElementById(`track-name-${di}`).innerText = file.name;
  document.getElementById(`deck-${di}`).classList.add('active');
  document.getElementById(`bpm-analyzing-${di}`).style.display='inline';
  document.getElementById(`bpm-${di}`).innerText='...';

  const arrBuf = await file.arrayBuffer();
  ctx.decodeAudioData(arrBuf, async (buffer) => {
    const d = decks[di];
    d.buffer = buffer;
    d.duration = buffer.duration;
    d.pausePosition = 0;
    d.hotcues = Array(8).fill(null);
    d.loopStart=null; d.loopEnd=null; d.loopActive=false;
    d.zoomLevel=1; d.zoomOffset=0;
    document.getElementById(`time-total-${di}`).textContent = formatTime(buffer.duration);

    // Build waveform peaks first (for drawing)
    d.waveformPeaks = buildWaveformPeaks(buffer, 2000);

    // Deep BPM analysis ‚Äî runs async-style with setTimeout to not block
    document.getElementById(`bpm-${di}`).innerText='...';
    setTimeout(() => {
      const candidates = detectBPMDeep(buffer);
      d.bpmCandidates = candidates;
      const best = candidates[0]?.bpm || 120;
      d.bpm = best; d.originalBpm = best;
      document.getElementById(`bpm-${di}`).innerText = best.toFixed(1);
      document.getElementById(`bpm-live-${di}`).innerText = (best * d.speed).toFixed(1);
      document.getElementById(`bpm-analyzing-${di}`).style.display='none';
      d.beats = computeBeats(buffer, best, d.beatOffset);
      d.detectedKey = detectKey(buffer);
      updateKeyDisplay(di);
      renderWaveform(di);
      drawBeatMarkers(di);
      updateZoomLabel(di);
    }, 10);
  }, e => { console.error(e); alert('Errore decodifica audio.'); });
}

// ===================== WAVEFORM PEAKS =====================
function buildWaveformPeaks(buffer, resolution) {
  const data = buffer.getChannelData(0);
  const step = Math.ceil(data.length / resolution);
  const mins = new Float32Array(resolution);
  const maxs = new Float32Array(resolution);
  for(let x=0;x<resolution;x++) {
    let mn=1,mx=-1;
    for(let s=0;s<step;s++) {
      const v = data[x*step+s]||0;
      if(v<mn) mn=v; if(v>mx) mx=v;
    }
    mins[x]=mn; maxs[x]=mx;
  }
  return {mins,maxs,resolution};
}

function renderWaveform(di) {
  const d = decks[di];
  if(!d.buffer || !d.waveformPeaks) return;
  const canvas = document.getElementById(`wf-${di}`);
  const wrap = document.getElementById(`wf-wrap-${di}`);
  canvas.width = wrap.offsetWidth || 320;
  canvas.height = 90;
  const c = canvas.getContext('2d');
  const w = canvas.width, h = canvas.height;
  const halfH = h/2;
  const col = colors[di];

  // Background
  const grad = c.createLinearGradient(0,0,0,h);
  grad.addColorStop(0,'#0a0a10');
  grad.addColorStop(0.5,'#111118');
  grad.addColorStop(1,'#0a0a10');
  c.fillStyle=grad; c.fillRect(0,0,w,h);
  // Center line
  c.strokeStyle='#222'; c.lineWidth=1;
  c.beginPath(); c.moveTo(0,halfH); c.lineTo(w,halfH); c.stroke();

  const {mins,maxs,resolution} = d.waveformPeaks;
  const zoom = d.zoomLevel;
  const viewFraction = 1/zoom;
  const viewStart = d.zoomOffset;
  const viewEnd = viewStart + viewFraction;

  const startIdx = Math.floor(viewStart*resolution);
  const endIdx = Math.ceil(viewEnd*resolution);
  const pxPerSample = w / (endIdx - startIdx);

  for(let idx=startIdx; idx<endIdx; idx++) {
    const x = Math.round((idx-startIdx)*pxPerSample);
    const mn = mins[idx]||0, mx = maxs[idx]||0;
    const amp = Math.abs(mx-mn);
    const bright = Math.min(1, amp*2.5);
    const r=parseInt(col.slice(1,3),16), g=parseInt(col.slice(3,5),16), b=parseInt(col.slice(5,7),16);
    c.fillStyle=`rgba(${r},${g},${b},${0.25+bright*0.75})`;
    const topY = halfH - mx*halfH;
    const botY = halfH - mn*halfH;
    c.fillRect(x, topY, Math.max(1,Math.ceil(pxPerSample)), Math.max(1,botY-topY));
  }
}

// ===================== BEAT MARKERS =====================
function computeBeats(buffer, bpm, offsetMs) {
  const spb = 60/bpm;
  const offsetSec = (offsetMs||0)/1000;
  const dur = buffer.duration;
  const beats = [];
  let t = offsetSec;
  if(t<0) t += spb * Math.ceil(-t/spb);
  while(t<dur) { beats.push(t); t+=spb; }
  return beats;
}

function drawBeatMarkers(di) {
  const d = decks[di];
  if(!d.buffer) return;
  const canvas = document.getElementById(`beatcanvas-${di}`);
  const wrap = document.getElementById(`wf-wrap-${di}`);
  canvas.width = wrap.offsetWidth||320;
  canvas.height = 90;
  const c = canvas.getContext('2d');
  c.clearRect(0,0,canvas.width,canvas.height);
  const w = canvas.width, dur = d.buffer.duration;
  const zoom = d.zoomLevel;
  const viewFraction = 1/zoom;
  const viewStart = d.zoomOffset;
  const viewEnd = viewStart + viewFraction;

  d.beats.forEach((bt,bi) => {
    const frac = bt/dur;
    if(frac<viewStart || frac>viewEnd) return;
    const x = ((frac-viewStart)/viewFraction)*w;
    const isBeat1 = bi%4===0;  // downbeat of measure
    const isBeat = true;

    if(isBeat1) {
      // Strong beat-1: golden full height line
      c.strokeStyle = 'rgba(255,220,0,0.9)';
      c.lineWidth = 1.5;
      c.beginPath(); c.moveTo(x,0); c.lineTo(x,canvas.height); c.stroke();
      // Beat 1 number label
      const measure = Math.floor(bi/4)+1;
      c.fillStyle = 'rgba(255,220,0,0.85)';
      c.font = 'bold 9px monospace';
      c.fillText(measure, x+2, 10);
      // Thick top accent
      c.fillStyle = 'rgba(255,220,0,0.6)';
      c.fillRect(x-0.5,0,2,4);
    } else {
      // Regular beats: white, shorter
      c.strokeStyle = 'rgba(255,255,255,0.3)';
      c.lineWidth = 0.8;
      c.beginPath(); c.moveTo(x,20); c.lineTo(x,70); c.stroke();
    }
  });

  // Hotcues
  d.hotcues.forEach((pos,hi) => {
    if(pos===null) return;
    const frac = pos/dur;
    if(frac<viewStart || frac>viewEnd) return;
    const x = ((frac-viewStart)/viewFraction)*w;
    c.strokeStyle = HCCOLORS[hi];
    c.lineWidth = 2;
    c.beginPath(); c.moveTo(x,0); c.lineTo(x,canvas.height); c.stroke();
    c.fillStyle = HCCOLORS[hi];
    c.font = 'bold 9px monospace';
    c.fillText(hi+1, x+2, 22);
  });
}

// ===================== ZOOM =====================
function zoomIn(di) {
  const d = decks[di];
  d.zoomLevel = Math.min(64, d.zoomLevel*2);
  clampZoomOffset(di);
  updateZoomLabel(di);
  renderWaveform(di);
  drawBeatMarkers(di);
}
function zoomOut(di) {
  const d = decks[di];
  d.zoomLevel = Math.max(1, d.zoomLevel/2);
  clampZoomOffset(di);
  updateZoomLabel(di);
  renderWaveform(di);
  drawBeatMarkers(di);
}
function zoomReset(di) {
  decks[di].zoomLevel=1; decks[di].zoomOffset=0;
  updateZoomLabel(di);
  renderWaveform(di);
  drawBeatMarkers(di);
}
function clampZoomOffset(di) {
  const d = decks[di];
  const viewFraction = 1/d.zoomLevel;
  if(d.zoomOffset+viewFraction>1) d.zoomOffset = Math.max(0,1-viewFraction);
  if(d.zoomOffset<0) d.zoomOffset=0;
}
function updateZoomLabel(di) {
  document.getElementById(`zoom-label-${di}`).textContent = `ZOOM ${decks[di].zoomLevel}x`;
}

// Scroll zoom via wheel
function wfWheel(di, e) {
  e.preventDefault();
  if(e.deltaY<0) zoomIn(di); else zoomOut(di);
}

// Pan via drag
let wfDrag = Array(4).fill(null);
function wfMouseDown(di,e) {
  wfDrag[di]={x:e.clientX, offset0:decks[di].zoomOffset};
}
function wfMouseMove(di,e) {
  if(!wfDrag[di]) return;
  const d = decks[di];
  const wrap = document.getElementById(`wf-wrap-${di}`);
  const w = wrap.offsetWidth;
  const dx = (e.clientX - wfDrag[di].x)/w;
  d.zoomOffset = Math.max(0, Math.min(1-1/d.zoomLevel, wfDrag[di].offset0 - dx/d.zoomLevel * d.zoomLevel));
  // Actually: pan fraction = dx / w * viewFraction
  const viewFraction = 1/d.zoomLevel;
  d.zoomOffset = wfDrag[di].offset0 - dx * viewFraction;
  clampZoomOffset(di);
  renderWaveform(di);
  drawBeatMarkers(di);
}
function wfMouseUp(di,e) {
  if(!wfDrag[di]) return;
  const dx = Math.abs(e.clientX - wfDrag[di].x);
  wfDrag[di]=null;
  // If minimal drag = it's a click ‚Üí seek
  if(dx<5) seekByClick(di,e);
}

// ===================== SEEK =====================
function seekByClick(di, e) {
  const d = decks[di];
  if(!d.buffer) return;
  const wrap = document.getElementById(`wf-wrap-${di}`);
  const rect = wrap.getBoundingClientRect();
  const pct = (e.clientX - rect.left)/rect.width;
  const viewFraction = 1/d.zoomLevel;
  const globalFrac = d.zoomOffset + pct*viewFraction;
  const newPos = globalFrac * d.buffer.duration;
  d.pausePosition = Math.max(0, Math.min(newPos, d.buffer.duration-0.01));
  if(d.isPlaying) playDeck(di);
  else {
    updatePlayheadPosition(di);
    document.getElementById(`time-elapsed-${di}`).textContent = formatTimeSub(d.pausePosition);
    document.getElementById(`time-remaining-${di}`).textContent = '-'+formatTimeSub(d.buffer.duration-d.pausePosition);
  }
}

// ===================== PLAYBACK =====================
// KEY LOCK IMPLEMENTATION:
// When key lock is OFF: playbackRate = speed * pitchMultiplier ‚Üí changes both tempo AND pitch
// When key lock is ON:  playbackRate = speed (tempo only) + pitchShift via a separate
//                       technique: we re-create the AudioBufferSourceNode using the speed
//                       for playbackRate, and apply semitone/cents via a separate gain+pitch
//                       node chain using a ScriptProcessor or AudioWorklet if available.
//                       As a pragmatic fallback without AudioWorklet, we use the approach of
//                       resampling: when key lock is ON, speed changes only playbackRate
//                       but pitch offset is applied by creating a resampled buffer at the
//                       semitone-shifted rate, keeping the PLAYBACK rate = speed.
//
// For simplicity & broad browser support, we implement key lock using:
// - playbackRate = speed  (changes tempo)
// - pitch shift = separate AudioBufferSourceNode with adjusted rate = pitchMultiplier, but
//   the BUFFER is played at speed, so the effective pitch stays locked to originalPitch.
//
// Correct formula:
//   Without key lock: playbackRate = speed * pitchMultiplier
//   With key lock:    playbackRate = speed (tempo)
//                     + pitch shifted by (semitones+cents) INDEPENDENTLY
//
// We implement this by creating TWO audio paths:
//  1. Normal: one source node, playbackRate = speed * pitchFactor
//  2. Key lock: one source node, playbackRate = speed (ONLY speed affects tempo)
//              Then we apply pitch shift via a GainNode connected chain that uses the
//              AudioContext's baseLatency... Actually the cleanest solution without Worklet:
//              Use the fact that to shift pitch by N semitones WITHOUT changing tempo,
//              we can play a "pitched buffer" that was resampled.
//
// PRACTICAL IMPLEMENTATION for browsers without AudioWorklet:
// Use two AudioBufferSourceNode trick:
//  - source1 plays at rate=speed (correct tempo)  
//  - For pitch shift: create a derived buffer at (pitchFactor * original sampleRate) and
//    play it at rate=1 ‚Äî this shifts pitch but NOT tempo. Then route thru gain=0.5.
//    Combine both at mix = 0 when key lock off, mix correctly when on.
// This is complex. Instead we use a simple but effective trick:
// Store pitchShiftSemitones separately, and when computing playbackRate:
//   keyLock OFF: rate = speed * pitchFactor (pitch and tempo linked)
//   keyLock ON:  rate = speed * pitchFactor / pitchFactor = speed (ONLY speed)
//                but we create an additional source that plays the buffer at pitchFactor
//                rate and mixes it... TOO COMPLEX for reliable result.
//
// SIMPLEST CORRECT APPROACH (used here):
// Use Web Audio's ability to create a resampled buffer:
//   When key lock is ON and user changes speed slider:
//     ‚Üí playbackRate stays at 1.0 (original speed)
//     ‚Üí we create a NEW AudioBuffer resampled to (speed) via OfflineAudioContext
//     ‚Üí that way tempo changes without pitch change
//   When pitch shift is requested:
//     ‚Üí we apply pitchFactor to the resampled buffer's playbackRate
// This is the most accurate approach but requires buffer re-render on speed change.
// For real-time performance, we throttle to only re-render when speed changes significantly.
//
// For smooth playback, we use the following simplified working approach:
// - KeyLock OFF: playbackRate = speed * semitoneMultiplier (both change together)
// - KeyLock ON:  playbackRate = speed (tempo only, pitch stays at semitoneMultiplier√óoriginal)
//               Pitch shift is approximated by creating a secondary "pitch-only" source
//               that overlaps. Not perfect but functional without AudioWorklet.
// NOTE: True key lock requires AudioWorklet with phase vocoder. Here we implement
// the closest approximation possible with standard Web Audio API.

function computePlaybackRate(di) {
  const d = decks[di];
  const pitchFactor = Math.pow(2, (d.semitones + d.cents/100)/12);
  if(d.keyLock) {
    // Key lock ON: only speed affects playback rate
    // Pitch offset is applied via d.pitchShift which we multiply independently
    return d.speed; // tempo only; pitch applied separately via pitchShift node
  } else {
    // Key lock OFF: both speed and pitch change together
    return d.speed * pitchFactor;
  }
}

function computePitchOnlyRate(di) {
  // The pitch-only rate for when key lock is ON
  const d = decks[di];
  return Math.pow(2, (d.semitones + d.cents/100)/12);
}

function playDeck(di) {
  if(!decks[di].buffer) { alert('Carica prima una traccia!'); return; }
  if(ctx.state==='suspended') ctx.resume();
  const d = decks[di];

  // Stop any existing sources
  stopSources(di);

  const offset = Math.max(0, Math.min(d.pausePosition, d.buffer.duration-0.01));

  if(d.keyLock) {
    // KEY LOCK MODE:
    // We play the buffer at d.speed (for tempo) and apply pitch via a separate
    // source playing a gain-mixed "pitch node". Since Web Audio lacks a pitch shifter,
    // we approximate by: source.playbackRate = speed, and a secondary source with
    // adjusted playbackRate = speed * pitchFactor playing into a separate gainNode
    // at full volume, while the main source plays at speed into gain=0.
    // Actually, the best available approach: use speed for tempo and accept that
    // pitch CANNOT be shifted independently without AudioWorklet.
    // But we CAN shift pitch WITHOUT tempo change: play buffer at rate=pitchFactor
    // through an offline context resampled to speed... still complex.
    //
    // WORKING KEY LOCK TRICK with Web Audio:
    // The trick: play at rate=1 from a buffer that has been OfflineContext-rendered
    // at the target tempo. This IS true key lock. We do it on demand.
    // For simplicity in this version, we implement it for the pitch-only case:
    //   - The "key lock" means changing speed does NOT change pitch.
    //   - We play at playbackRate = speed (changes tempo ‚úì)
    //   - pitch stays at pitchFactor (default 1 = no shift, or user-set semitones)
    //   - BUT playbackRate is speed, which WOULD change pitch...
    //   - Solution: create a secondary source at rate = pitchFactor/speed, 
    //     mixed via gain and phase, overlapping the main source for pitch correction.
    //     This is a "formant" approach.
    //
    // FINAL PRACTICAL DECISION: 
    // Use the OfflineAudioContext trick to pre-render a time-stretched version.
    // This is the only truly correct solution in Web Audio without AudioWorklet.
    // We render once and cache the stretched buffer.
    renderKeyLockBuffer(di, offset);
    return; // will call _playDecks internally
  }

  // NORMAL MODE (key lock off)
  const source = ctx.createBufferSource();
  source.buffer = d.buffer;
  source.playbackRate.value = computePlaybackRate(di);
  applyLoop(source, d);
  source.connect(d.gainNode);
  source.start(0, offset);
  d.source = source;
  d.startTime = ctx.currentTime;
  d.isPlaying = true;
  setPlayBtn(di, true);
  if(d.animFrame) cancelAnimationFrame(d.animFrame);
  animateDeck(di);
}

// Render time-stretched buffer for key lock mode (using OfflineAudioContext)
async function renderKeyLockBuffer(di, offset) {
  const d = decks[di];
  // We need to time-stretch by factor = d.speed (play at speed√ótempo but pitch-lock)
  // OfflineAudioContext approach: render the buffer at rate=speed into a new buffer
  // of duration = original_duration / speed. The resulting buffer has the same pitch
  // but different duration (= time stretched).
  // Then play the resulting buffer at rate=1 ‚Üí correct tempo AND correct pitch.
  // However, OfflineAudioContext rendering takes time, so we need to limit this.
  // For interactive speed changes, we debounce.
  
  // Only re-render if speed or pitch has changed significantly
  const speedKey = d.speed.toFixed(3) + '|' + d.semitones + '|' + d.cents;
  if(d._klBufferKey === speedKey && d._klBuffer) {
    _playKeyLock(di, offset, d._klBuffer);
    return;
  }

  const pitchFactor = Math.pow(2, (d.semitones + d.cents/100)/12);
  const totalRate = d.speed * pitchFactor;

  // Render: play original at totalRate into offline context of length original/speed
  // This produces a buffer with correct tempo (speed) and pitch offset (semitones)
  const newLength = Math.ceil(d.buffer.length / d.speed);
  const offCtx = new OfflineAudioContext(
    d.buffer.numberOfChannels,
    newLength,
    d.buffer.sampleRate
  );
  const src = offCtx.createBufferSource();
  src.buffer = d.buffer;
  src.playbackRate.value = totalRate; // plays fast/slow ‚Üí time compressed/stretched
  src.connect(offCtx.destination);
  src.start(0);

  try {
    const rendered = await offCtx.startRendering();
    d._klBuffer = rendered;
    d._klBufferKey = speedKey;
    _playKeyLock(di, offset, rendered);
  } catch(err) {
    console.warn('Key lock render failed, falling back:', err);
    // Fallback: normal playback
    d.keyLock = false;
    playDeck(di);
  }
}

function _playKeyLock(di, offset, klBuffer) {
  const d = decks[di];
  stopSources(di);
  // offset in original buffer ‚Üí map to key-locked buffer offset
  const klOffset = Math.max(0, Math.min(offset / d.speed, klBuffer.duration - 0.01));
  const source = ctx.createBufferSource();
  source.buffer = klBuffer;
  source.playbackRate.value = 1.0; // plays at rate 1 ‚Üí correct tempo
  // Apply loop if active (remap loop times)
  if(d.loopActive && d.loopStart!==null && d.loopEnd!==null) {
    source.loop = true;
    source.loopStart = d.loopStart / d.speed;
    source.loopEnd = d.loopEnd / d.speed;
  }
  source.connect(d.gainNode);
  source.start(0, klOffset);
  d.source = source;
  d.startTime = ctx.currentTime;
  d._klActive = true;
  d._klRatio = d.speed; // to convert positions back
  d.isPlaying = true;
  setPlayBtn(di, true);
  if(d.animFrame) cancelAnimationFrame(d.animFrame);
  animateDeck(di);
}

function stopSources(di) {
  const d = decks[di];
  if(d.source) { try{d.source.stop();}catch(e){} d.source=null; }
  d._klActive = false;
}

function applyLoop(source, d) {
  if(d.loopActive && d.loopStart!==null && d.loopEnd!==null) {
    source.loop=true; source.loopStart=d.loopStart; source.loopEnd=d.loopEnd;
  } else { source.loop=false; }
}

function pauseDeck(di) {
  const d = decks[di];
  d.pausePosition = getCurrentPosition(di);
  stopSources(di);
  d.isPlaying=false;
  setPlayBtn(di,false);
}

function stopDeck(di) {
  const d = decks[di];
  stopSources(di);
  d.isPlaying=false;
  d.pausePosition=0;
  d._klActive=false;
  setPlayBtn(di,false);
  document.getElementById(`time-elapsed-${di}`).textContent='0:00.0';
  document.getElementById(`time-remaining-${di}`).textContent='-'+formatTime(d.duration);
  if(d.animFrame) cancelAnimationFrame(d.animFrame);
  updatePlayheadPosition(di);
  renderWaveform(di);
  drawBeatMarkers(di);
}

function setPlayBtn(di, playing) {
  const btn = document.getElementById(`btn-play-${di}`);
  if(playing) {
    btn.textContent='‚ùö‚ùö Pause';
    btn.onclick=()=>pauseDeck(di);
  } else {
    btn.textContent='‚ñ∂ Play';
    btn.onclick=()=>playDeck(di);
  }
}

function getCurrentPosition(di) {
  const d = decks[di];
  if(!d.isPlaying) return d.pausePosition;
  if(d._klActive) {
    // klBuffer is compressed/stretched ‚Äî map back to original position
    return d.pausePosition + (ctx.currentTime - d.startTime); // rate=1 so 1:1 seconds
    // Actually pause position was in original space, klOffset was pausePosition/speed
    // Now elapsed time = ctx.currentTime - startTime
    // elapsed_in_original = elapsed * speed (since klBuffer plays at 1x but corresponds to speed* original)
    return d.pausePosition + (ctx.currentTime - d.startTime) * d.speed;
  }
  return d.pausePosition + (ctx.currentTime - d.startTime) * d.speed;
}

function animateDeck(di) {
  const d = decks[di];
  if(!d.isPlaying) return;
  const pos = getCurrentPosition(di);
  const dur = d.buffer ? d.buffer.duration : 1;
  if(pos >= dur) { stopDeck(di); return; }
  updatePlayheadPosition(di);
  document.getElementById(`time-elapsed-${di}`).textContent = formatTimeSub(pos);
  document.getElementById(`time-remaining-${di}`).textContent = '-'+formatTimeSub(dur-pos);
  // Auto-pan zoom to follow playhead
  if(d.zoomLevel > 1) {
    const frac = pos/dur;
    const viewFraction = 1/d.zoomLevel;
    const viewCenter = d.zoomOffset + viewFraction/2;
    if(Math.abs(frac-viewCenter) > viewFraction*0.4) {
      d.zoomOffset = Math.max(0, Math.min(1-viewFraction, frac - viewFraction/2));
      renderWaveform(di);
      drawBeatMarkers(di);
    }
  }
  d.animFrame = requestAnimationFrame(()=>animateDeck(di));
}

function updatePlayheadPosition(di) {
  const d = decks[di];
  const pos = d.isPlaying ? getCurrentPosition(di) : d.pausePosition;
  const dur = d.buffer ? d.buffer.duration : 1;
  const frac = Math.min(1, pos/dur);
  const viewFraction = 1/d.zoomLevel;
  // Playhead is always at center of waveform in zoom>1 mode when auto-following
  // In zoom=1, it moves across the full waveform
  let left;
  if(d.zoomLevel===1) {
    left = frac*100+'%';
  } else {
    const viewStart = d.zoomOffset;
    const viewEnd = viewStart+viewFraction;
    if(frac<viewStart||frac>viewEnd) {
      left = '-10px'; // off screen
    } else {
      left = ((frac-viewStart)/viewFraction*100)+'%';
    }
  }
  document.getElementById(`playhead-${di}`).style.left = left;
}

// ===================== TIME FORMAT =====================
function formatTime(s) {
  if(isNaN(s)||s<0) s=0;
  const m=Math.floor(s/60), ss=Math.floor(s%60);
  return `${m}:${ss.toString().padStart(2,'0')}`;
}
function formatTimeSub(s) {
  if(isNaN(s)||s<0) s=0;
  const m=Math.floor(s/60), ss=(s%60).toFixed(1);
  return `${m}:${ss.padStart(4,'0')}`;
}

// ===================== CUE / LOOP / HOTCUE =====================
function setCue(di) {
  const d = decks[di];
  d.pausePosition = getCurrentPosition(di);
  if(d.isPlaying) pauseDeck(di);
}
function toggleLoop(di) {
  const d = decks[di];
  if(!d.loopActive) {
    d.loopStart = getCurrentPosition(di);
    d.loopEnd = d.loopStart + (60/(d.bpm||120))*4;
    d.loopActive=true;
  } else {
    d.loopActive=false;
    if(d.source) d.source.loop=false;
  }
  document.getElementById(`btn-loop-${di}`).style.background = d.loopActive?'#5a2200':'#7a4a1a';
  document.getElementById(`btn-loop-${di}`).textContent = d.loopActive?'üîÅ LOOP ON':'LOOP 4B';
  if(d.isPlaying) playDeck(di);
}
function hotcueAction(di,slot) {
  const d = decks[di];
  if(d.hotcues[slot]===null) {
    d.hotcues[slot] = getCurrentPosition(di);
    const btn = document.getElementById(`hc-${di}-${slot}`);
    btn.style.opacity='1'; btn.style.borderColor=HCCOLORS[slot]; btn.style.boxShadow=`0 0 5px ${HCCOLORS[slot]}`;
  } else {
    d.pausePosition=d.hotcues[slot];
    if(d.isPlaying) playDeck(di);
    else { updatePlayheadPosition(di); }
  }
  drawBeatMarkers(di);
}
document.addEventListener('contextmenu',e=>{
  const btn=e.target.closest('.hotcue-btn');
  if(!btn) return;
  e.preventDefault();
  const parts=btn.id.split('-');
  const di=parseInt(parts[1]),slot=parseInt(parts[2]);
  decks[di].hotcues[slot]=null;
  const b=document.getElementById(`hc-${di}-${slot}`);
  b.style.opacity='0.5'; b.style.boxShadow=''; b.style.borderColor='';
  drawBeatMarkers(di);
});

// ===================== SPEED / PITCH CONTROLS =====================
function setSpeed(di, val) {
  const d = decks[di];
  d.speed = parseFloat(val);
  d._klBuffer = null; // invalidate key lock cache
  document.getElementById(`rate-val-${di}`).innerText = parseFloat(val).toFixed(3);
  document.getElementById(`bpm-live-${di}`).innerText = (d.originalBpm * d.speed).toFixed(1);
  if(d.isPlaying) {
    if(d.keyLock) {
      // Re-render key lock buffer with new speed
      const pos = getCurrentPosition(di);
      d.pausePosition = pos;
      playDeck(di); // will re-render
    } else {
      if(d.source) d.source.playbackRate.value = computePlaybackRate(di);
    }
  }
}

function setPitchSlider(di, val) {
  const d = decks[di];
  d.semitones = parseFloat(val);
  d.cents = 0;
  d._klBuffer = null;
  document.getElementById(`pitch-st-val-${di}`).innerText = parseFloat(val).toFixed(1);
  updateKeyDisplay(di);
  if(d.isPlaying) {
    if(d.keyLock) {
      const pos = getCurrentPosition(di);
      d.pausePosition = pos;
      playDeck(di);
    } else {
      if(d.source) d.source.playbackRate.value = computePlaybackRate(di);
    }
  }
}

function toggleKeyLock(di) {
  const d = decks[di];
  d.keyLock = !d.keyLock;
  d._klBuffer = null;
  const btn = document.getElementById(`keylock-btn-${di}`);
  btn.classList.toggle('locked', d.keyLock);
  btn.textContent = d.keyLock ? 'üîí LOCK' : 'üîì LOCK';
  document.getElementById(`keylock-ind-${di}`).classList.toggle('active', d.keyLock);
  updateKeyDisplay(di);
  if(d.isPlaying) {
    const pos = getCurrentPosition(di);
    d.pausePosition = pos;
    playDeck(di);
  } else if(d.source) {
    d.source.playbackRate.value = computePlaybackRate(di);
  }
}

// ===================== EQ & VOLUME =====================
function setEQ(di,band,val) {
  const d=decks[di]; val=parseFloat(val);
  if(band==='low') { d.eqLow.gain.value=val; document.getElementById(`eq-low-val-${di}`).textContent=val; }
  if(band==='mid') { d.eqMid.gain.value=val; document.getElementById(`eq-mid-val-${di}`).textContent=val; }
  if(band==='high') { d.eqHigh.gain.value=val; document.getElementById(`eq-high-val-${di}`).textContent=val; }
}
function setVolume(di,val) { decks[di].gainNode.gain.value=val; }
function setMasterVolume(val) { masterGain.gain.value=val; }
function setCrossfader(val) {
  const vA=Math.cos(val*Math.PI/2), vB=Math.sin(val*Math.PI/2);
  if(decks[0].gainNode) decks[0].gainNode.gain.value=vA;
  if(decks[1].gainNode) decks[1].gainNode.gain.value=vB;
}

// ===================== SYNC =====================
function syncDeck(di) {
  const master=decks[masterDeckIndex], d=decks[di];
  if(di===masterDeckIndex) { alert(`Deck ${DECK_NAMES[di]} √® il Master.`); return; }
  if(master.bpm===0||d.bpm===0) { alert('BPM non rilevato ancora.'); return; }
  const ratio=(master.bpm*master.speed)/d.originalBpm;
  d.speed=ratio;
  const slider=document.getElementById(`speed-slider-${di}`);
  if(slider) slider.value=Math.max(0.5,Math.min(2,ratio));
  document.getElementById(`rate-val-${di}`).innerText=ratio.toFixed(3);
  document.getElementById(`bpm-live-${di}`).innerText=(d.originalBpm*ratio).toFixed(1);
  d._klBuffer=null;
  if(d.source && !d.keyLock) d.source.playbackRate.value=computePlaybackRate(di);
  else if(d.isPlaying && d.keyLock) { const pos=getCurrentPosition(di); d.pausePosition=pos; playDeck(di); }
}

// ===================== DEEP BPM ANALYSIS =====================
// Returns array of {bpm, confidence, count} sorted by confidence
function detectBPMDeep(buffer) {
  const data = buffer.getChannelData(0);
  const sr = buffer.sampleRate;
  const analysisLen = Math.min(data.length, sr*120); // max 120s

  // Onset detection via energy
  const hopSize = 512;
  const winSize = 1024;
  const numFrames = Math.floor((analysisLen-winSize)/hopSize);
  const energies = new Float32Array(numFrames);

  for(let f=0;f<numFrames;f++) {
    let sum=0;
    const off=f*hopSize;
    for(let s=0;s<winSize;s++) sum+=(data[off+s]||0)**2;
    energies[f]=Math.sqrt(sum/winSize);
  }

  // Onset via energy difference
  const onsets = [];
  const threshold = 0;
  let maxE=0;
  for(let f=0;f<numFrames;f++) if(energies[f]>maxE) maxE=energies[f];
  const thr = maxE * 0.55;

  for(let f=1;f<numFrames-1;f++) {
    if(energies[f]>thr && energies[f]>energies[f-1]*1.1) {
      if(onsets.length===0 || (f-onsets[onsets.length-1])>3) {
        onsets.push(f);
      }
    }
  }

  // Compute inter-onset intervals ‚Üí BPM map
  const bpmMap = {};
  for(let i=1;i<onsets.length;i++) {
    const iv = onsets[i]-onsets[i-1];
    if(iv<2) continue;
    const secPerBeat = iv*hopSize/sr;
    if(secPerBeat<0.2 || secPerBeat>2) continue;
    let bpm = Math.round(60/secPerBeat);
    // Normalize to 80-175 range
    while(bpm>175) bpm=Math.round(bpm/2);
    while(bpm<80) bpm=Math.round(bpm*2);
    if(bpm<60||bpm>210) continue;
    bpmMap[bpm]=(bpmMap[bpm]||0)+1;
  }

  // Also check fractional BPMs (0.5 BPM resolution)
  const bpmMap2 = {};
  for(let i=1;i<onsets.length;i++) {
    const iv = onsets[i]-onsets[i-1];
    if(iv<2) continue;
    const secPerBeat = iv*hopSize/sr;
    if(secPerBeat<0.2||secPerBeat>2) continue;
    let bpm = Math.round(6000/secPerBeat)/100; // 0.01 resolution
    while(bpm>175) bpm=bpm/2;
    while(bpm<80) bpm=bpm*2;
    if(bpm<60||bpm>210) continue;
    const key = Math.round(bpm*2)/2; // 0.5 resolution
    bpmMap2[key]=(bpmMap2[key]||0)+1;
  }

  // Merge maps
  const allMap = {};
  for(const k in bpmMap) allMap[k] = bpmMap[k];
  for(const k in bpmMap2) allMap[k] = (allMap[k]||0) + bpmMap2[k]*0.5;

  // Look for clusters of 4 consistent beats (detecting "4 constants")
  const constancyBonus = detectConstancyClusters(onsets, hopSize, sr);
  for(const bpm in constancyBonus) {
    if(allMap[bpm]) allMap[bpm] += constancyBonus[bpm]*3;
  }

  // Sort candidates
  const total = Object.values(allMap).reduce((a,b)=>a+b,0)||1;
  const candidates = Object.entries(allMap)
    .map(([bpm,count]) => ({bpm:parseFloat(bpm), count, confidence:count/total}))
    .sort((a,b)=>b.count-a.count)
    .slice(0,8);

  if(candidates.length===0) return [{bpm:120,confidence:1,count:1}];
  return candidates;
}

// Detect clusters of 4 consistent inter-onset intervals (the "4/4 constant" analysis)
function detectConstancyClusters(onsets, hopSize, sr) {
  const bonus = {};
  for(let i=0; i<onsets.length-4; i++) {
    const ivs = [onsets[i+1]-onsets[i], onsets[i+2]-onsets[i+1], onsets[i+3]-onsets[i+2], onsets[i+4]-onsets[i+3]];
    const mean = ivs.reduce((a,b)=>a+b,0)/4;
    const variance = ivs.reduce((a,b)=>a+(b-mean)**2,0)/4;
    const cv = Math.sqrt(variance)/mean;
    if(cv < 0.08) { // very consistent ‚Äî likely real 4 beat pattern
      const secPerBeat = mean*hopSize/sr;
      if(secPerBeat<0.2||secPerBeat>2) continue;
      let bpm = Math.round(60/secPerBeat);
      while(bpm>175) bpm=Math.round(bpm/2);
      while(bpm<80) bpm=Math.round(bpm*2);
      bonus[bpm]=(bonus[bpm]||0)+1;
    }
  }
  return bonus;
}

// ===================== KEY DETECTION =====================
function detectKey(buffer) {
  try {
    const data = buffer.getChannelData(0);
    const sr = buffer.sampleRate;
    const len = Math.min(data.length, sr*60);
    const chroma = new Float32Array(12);
    const block = 2048;
    for(let i=0;i<len-block;i+=block) {
      for(let c=0;c<12;c++) {
        const freq = 261.63*Math.pow(2,c/12);
        const bin = Math.round(freq*block/sr);
        let e=0;
        for(let b=Math.max(0,bin-3);b<=Math.min(block/2,bin+3);b++) e+=(data[i+b]||0)**2;
        chroma[c]+=e;
      }
    }
    let maxE=0, key=0;
    for(let c=0;c<12;c++) if(chroma[c]>maxE){maxE=chroma[c];key=c;}
    return key;
  } catch(e) { return null; }
}

// ===================== KEY DISPLAY =====================
function updateKeyDisplay(di) {
  const d = decks[di];
  const el = document.getElementById(`key-detected-${di}`);
  const el2 = document.getElementById(`key-result-${di}`);
  if(d.detectedKey!==null) {
    el.textContent = NOTE_NAMES[d.detectedKey];
    el.classList.add('detected');
    const rk = ((d.detectedKey + Math.round(d.semitones+d.cents/100))%12+12)%12;
    el2.textContent = NOTE_NAMES[rk]+(d.cents!==0?` ${d.cents>0?'+':''}${d.cents}¬¢`:'');
  } else { el.textContent='‚Äî'; el2.textContent='‚Äî'; }
}

// ===================== POPUPS =====================
function openPopup(id) { document.getElementById(id).classList.add('open'); }
function closePopup(id) { document.getElementById(id).classList.remove('open'); }
document.querySelectorAll('.popup-overlay').forEach(o=>{
  o.addEventListener('click',e=>{ if(e.target===o) o.classList.remove('open'); });
});

// --- BPM POPUP ---
function openBpmPopup(di) {
  popupDeck=di;
  const d=decks[di];
  document.getElementById('popup-bpm-val').value = d.bpm.toFixed(1)||'120';
  document.getElementById('popup-beat-offset').value = d.beatOffset;
  document.getElementById('popup-beat-offset-display').textContent = d.beatOffset+' ms';
  // Render candidates
  const box = document.getElementById('bpm-candidates-box');
  if(d.bpmCandidates && d.bpmCandidates.length>0) {
    const maxCount = d.bpmCandidates[0].count;
    box.innerHTML = d.bpmCandidates.map((c,i)=>{
      const barW = Math.round((c.count/maxCount)*80);
      const sel = Math.abs(c.bpm - d.bpm)<0.1 ? 'selected' : (i===0?'best':'');
      return `<div class="bpm-candidate ${sel}" onclick="selectBpmCandidate(${c.bpm})">
        ${c.bpm.toFixed(1)} BPM
        <span class="confidence-bar" style="width:${barW}px"></span>
        <span style="color:#555;font-size:0.65rem"> ${(c.confidence*100).toFixed(1)}%</span>
      </div>`;
    }).join('');
  } else {
    box.innerHTML = '<span style="color:#555">Analisi non ancora effettuata</span>';
  }
  openPopup('popup-bpm');
}
function selectBpmCandidate(bpm) {
  document.getElementById('popup-bpm-val').value = bpm.toFixed(1);
  // highlight
  document.querySelectorAll('.bpm-candidate').forEach(el => {
    el.classList.toggle('selected', Math.abs(parseFloat(el.textContent)-bpm)<0.1);
  });
}
function halveBpm() {
  const v=parseFloat(document.getElementById('popup-bpm-val').value||120);
  document.getElementById('popup-bpm-val').value=(v/2).toFixed(1);
}
function doubleBpm() {
  const v=parseFloat(document.getElementById('popup-bpm-val').value||120);
  document.getElementById('popup-bpm-val').value=(v*2).toFixed(1);
}
function updateBeatOffsetDisplay(v) {
  document.getElementById('popup-beat-offset-display').textContent=v+' ms';
}
function nudgeOffset(delta) {
  const sl=document.getElementById('popup-beat-offset');
  sl.value=parseInt(sl.value)+delta;
  updateBeatOffsetDisplay(sl.value);
}
function previewBpmChange() {}
function confirmBPM() {
  const d=decks[popupDeck];
  const newBpm=parseFloat(document.getElementById('popup-bpm-val').value);
  const newOffset=parseInt(document.getElementById('popup-beat-offset').value);
  if(newBpm>0) {
    d.bpm=newBpm; d.originalBpm=newBpm;
    document.getElementById(`bpm-${popupDeck}`).innerText=newBpm.toFixed(1);
    document.getElementById(`bpm-live-${popupDeck}`).innerText=(newBpm*d.speed).toFixed(1);
  }
  d.beatOffset=newOffset;
  if(d.buffer) {
    d.beats=computeBeats(d.buffer,d.bpm,d.beatOffset);
    drawBeatMarkers(popupDeck);
  }
  closePopup('popup-bpm');
}

// --- KEY POPUP ---
let popupSemitones=0, popupCents=0;
function openKeyPopup(di) {
  popupDeck=di;
  const d=decks[di];
  popupSemitones=d.semitones;
  popupCents=d.cents;
  document.getElementById('popup-keylock').value=d.keyLock?'1':'0';
  document.getElementById('popup-semitone-display').textContent=popupSemitones+' st';
  document.getElementById('popup-cents').value=popupCents;
  document.getElementById('popup-cents-display').textContent=popupCents+' ¬¢';
  document.getElementById('popup-key-original').textContent=d.detectedKey!==null?NOTE_NAMES[d.detectedKey]:'‚Äî';
  updateResultKey();
  openPopup('popup-key');
}
function adjSemitone(delta) {
  popupSemitones=Math.max(-12,Math.min(12,popupSemitones+delta));
  document.getElementById('popup-semitone-display').textContent=popupSemitones+' st';
  updateResultKey();
}
function updateCentsDisplay(v) {
  popupCents=parseInt(v);
  document.getElementById('popup-cents-display').textContent=v+' ¬¢';
  updateResultKey();
}
function updateResultKey() {
  const d=decks[popupDeck];
  if(d.detectedKey!==null) {
    const rk=((d.detectedKey+popupSemitones)%12+12)%12;
    document.getElementById('popup-key-result').textContent=NOTE_NAMES[rk]+(popupCents!==0?` ${popupCents>0?'+':''}${popupCents}¬¢`:'');
  }
}
function confirmKey() {
  const d=decks[popupDeck];
  d.keyLock=document.getElementById('popup-keylock').value==='1';
  d.semitones=popupSemitones;
  d.cents=popupCents;
  d._klBuffer=null;
  updateKeyDisplay(popupDeck);
  const btn=document.getElementById(`keylock-btn-${popupDeck}`);
  btn.classList.toggle('locked',d.keyLock);
  btn.textContent=d.keyLock?'üîí LOCK':'üîì LOCK';
  document.getElementById(`keylock-ind-${popupDeck}`).classList.toggle('active',d.keyLock);
  // Update pitch slider
  document.getElementById(`pitch-slider-${popupDeck}`).value=d.semitones;
  document.getElementById(`pitch-st-val-${popupDeck}`).innerText=d.semitones.toFixed(1);
  if(d.isPlaying) { const pos=getCurrentPosition(popupDeck); d.pausePosition=pos; playDeck(popupDeck); }
  else if(d.source) d.source.playbackRate.value=computePlaybackRate(popupDeck);
  closePopup('popup-key');
}
function resetKey() {
  popupSemitones=0; popupCents=0;
  document.getElementById('popup-semitone-display').textContent='0 st';
  document.getElementById('popup-cents').value=0;
  document.getElementById('popup-cents-display').textContent='0 ¬¢';
  updateResultKey();
}

// ===================== RESIZE =====================
window.addEventListener('resize',()=>{
  decks.forEach((d,i)=>{ if(d.buffer){ renderWaveform(i); drawBeatMarkers(i); } });
});
</script>
</body>
</html>
