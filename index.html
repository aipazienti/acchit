<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover" />
  <title>maracanaudio - Accordatore</title>

  <meta name="theme-color" content="#111111">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <style>
    *{margin:0;padding:0;box-sizing:border-box;}
    html,body{height:100%;width:100%;overflow:hidden;background:#000;}
    body{font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;}

    /* Fullscreen app shell */
    .app{
      position:fixed; inset:0;
      display:flex;
      background: radial-gradient(circle at center, #151515 0%, #000 70%);
      color:#fff;
    }

    /* Main tuner */
    .tuner{
      flex:1;
      display:flex;
      flex-direction:column;
      padding: clamp(10px, 2.5vw, 22px);
      gap: clamp(8px, 1.8vh, 14px);
      justify-content:center;
      align-items:stretch;
    }

    .topRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      border-radius:14px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.10);
      backdrop-filter: blur(8px);
      user-select:none;
    }

    .btn{
      appearance:none;
      border:none;
      cursor:pointer;
      padding:10px 12px;
      border-radius:14px;
      font-weight:900;
      font-size:14px;
      color:#fff;
      background: rgba(42,82,152,0.95);
      transition: transform .12s ease, filter .12s ease;
      user-select:none;
      white-space:nowrap;
    }
    .btn:active{transform:scale(0.98);}
    .btn.secondary{background: rgba(255,255,255,0.10);}
    .btn.danger{background: rgba(220,53,69,0.95);}

    .readout{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:6px;
      padding: 8px 0;
    }

    .noteLine{
      font-size: clamp(34px, 8vw, 64px);
      font-weight: 1000;
      letter-spacing: 0.5px;
      text-shadow: 0 0 18px rgba(0,255,0,0.35);
    }

    .freqLine{
      font-size: clamp(18px, 3.7vw, 28px);
      font-weight: 900;
      opacity: 0.95;
    }

    .deltaLine{
      font-size: clamp(16px, 3.2vw, 22px);
      font-weight: 900;
      color: #ffd700;
    }

    .meter{
      position:relative;
      height: clamp(170px, 38vh, 280px);
      border-radius: 18px;
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      border: 1px solid rgba(255,255,255,0.10);
      overflow:hidden;
    }

    .scale{
      position:absolute; inset:0;
      display:flex;
      justify-content:space-between;
      padding: 0 clamp(12px, 2.8vw, 28px);
      align-items:stretch;
    }
    .mark{
      width:2px; background: rgba(255,255,255,0.18);
      position:relative;
    }
    .mark.center{
      width:3px;
      background: rgba(0,255,0,0.95);
      box-shadow: 0 0 14px rgba(0,255,0,0.5);
    }
    .label{
      position:absolute;
      bottom:10px;
      left:50%;
      transform:translateX(-50%);
      font-size: 12px;
      font-weight: 900;
      color: rgba(255,255,255,0.62);
      white-space:nowrap;
    }

    .needle{
      position:absolute;
      top:10%;
      height:80%;
      width: 4px;
      left:50%;
      transform: translateX(-50%);
      border-radius:2px;
      background: rgba(255,0,0,0.95);
      box-shadow: 0 0 14px rgba(255,0,0,0.55);
      transition: left .08s ease-out;
    }
    .needle.ok{
      background: rgba(0,255,0,0.95);
      box-shadow: 0 0 18px rgba(0,255,0,0.6);
    }

    .status{
      text-align:center;
      font-weight:1000;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.06);
      font-size: clamp(14px, 3vw, 18px);
    }
    .status.good{background: rgba(0,255,0,0.18); color:#d9ffd9; border-color: rgba(0,255,0,0.25);}
    .status.low{background: rgba(255,68,68,0.18); border-color: rgba(255,68,68,0.25);}
    .status.high{background: rgba(255,136,0,0.18); border-color: rgba(255,136,0,0.25);}

    /* Overlay: tap to start + fullscreen */
    .overlay{
      position:fixed; inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,0.78);
      z-index: 5000;
      padding: 14px;
    }
    .card{
      width: min(560px, 96vw);
      background: #fff;
      color:#111;
      border-radius: 18px;
      padding: 18px;
      box-shadow: 0 18px 70px rgba(0,0,0,0.45);
      text-align:center;
    }
    .card h2{font-size: 20px; font-weight: 1000; margin-bottom: 8px;}
    .card p{font-size: 14px; font-weight: 750; color:#444; line-height:1.4; margin-bottom: 14px;}
    .rowBtns{display:flex; gap:10px;}
    .rowBtns .btn{flex:1; border-radius:14px;}

    /* Reference modal */
    .refModal{
      position:fixed; inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,0.72);
      z-index: 5200;
      padding: 14px;
    }
    .refModal.show{display:flex;}
    .refCard{
      width:min(520px,96vw);
      background:#fff;
      color:#111;
      border-radius:18px;
      padding:18px;
      text-align:left;
      box-shadow: 0 18px 70px rgba(0,0,0,0.45);
    }
    .refCard h3{font-size:18px;font-weight:1000;margin-bottom:10px;}
    .refRow{display:flex; gap:10px; align-items:center;}
    .refRow input{
      flex:1;
      padding:12px 12px;
      border-radius:14px;
      border:2px solid #ddd;
      font-size:16px;
      font-weight:900;
      outline:none;
    }
    .hint{
      margin-top:10px;
      font-size:13px;
      font-weight:800;
      color:#555;
    }

    @media (orientation: landscape) and (max-height: 520px){
      .meter{height: clamp(160px, 46vh, 260px);}
      .topRow .pill{padding:8px 10px;}
      .btn{padding:10px 12px;}
    }
  </style>
</head>

<body>
  <div class="app">
    <div class="tuner" id="tunerRoot">
      <div class="topRow">
        <div class="pill" id="refPill">
          <span style="font-weight:1000;">A4</span>
          <span id="refVal" style="font-weight:1000;">440.0 Hz</span>
        </div>

        <div style="display:flex; gap:10px;">
          <button class="btn secondary" id="refBtn">LA (A4)</button>
          <button class="btn danger" id="stopBtn" style="display:none;">STOP</button>
        </div>
      </div>

      <div class="readout">
        <div class="noteLine" id="noteName">—</div>
        <div class="freqLine" id="freqNow">— Hz</div>
        <div class="deltaLine" id="deltaNow">0 cents</div>
      </div>

      <div class="meter" id="meter">
        <div class="scale" id="scale"></div>
        <div class="needle" id="needle"></div>
      </div>

      <div class="status" id="status">Tocca AVVIA per iniziare</div>
    </div>
  </div>

  <!-- TAP-TO-START overlay (starts mic + fullscreen) -->
  <div class="overlay" id="startOverlay">
    <div class="card">
      <h2>Accordatore</h2>
      <p>
        Tocca “AVVIA” per attivare il microfono e aprire a schermo intero.
        <br/>LA di riferimento: <b id="overlayRef">440.0 Hz</b>
      </p>
      <div class="rowBtns">
        <button class="btn secondary" id="overlayRefBtn">Cambia LA</button>
        <button class="btn" id="overlayStartBtn">AVVIA</button>
      </div>
      <p id="overlayErr" style="display:none; margin-top:12px; color:#b00020; font-weight:900;"></p>
    </div>
  </div>

  <!-- Reference modal -->
  <div class="refModal" id="refModal">
    <div class="refCard">
      <h3>Imposta LA (A4) manualmente</h3>
      <div class="refRow">
        <input id="refInput" type="number" min="380" max="520" step="0.1" value="440.0" />
        <button class="btn" id="refApply">Applica</button>
      </div>
      <div class="hint">Suggeriti: 440 (standard), 432, 442. La modifica aggiorna la scala note.</div>
      <div style="display:flex; gap:10px; margin-top:12px;">
        <button class="btn secondary" id="refClose">Chiudi</button>
      </div>
    </div>
  </div>

  <script>
    // =============================
    // Core: audio + pitch detection
    // =============================
    let audioContext, analyser, micSource, streamRef, rafId;
    let isRunning = false;

    // Reference A4
    let referenceA4 = 440.0;

    // UI
    const refVal = document.getElementById('refVal');
    const overlayRef = document.getElementById('overlayRef');
    const noteNameEl = document.getElementById('noteName');
    const freqNowEl = document.getElementById('freqNow');
    const deltaNowEl = document.getElementById('deltaNow');
    const statusEl = document.getElementById('status');
    const needleEl = document.getElementById('needle');
    const scaleEl = document.getElementById('scale');
    const stopBtn = document.getElementById('stopBtn');

    const startOverlay = document.getElementById('startOverlay');
    const overlayStartBtn = document.getElementById('overlayStartBtn');
    const overlayRefBtn = document.getElementById('overlayRefBtn');
    const overlayErr = document.getElementById('overlayErr');

    const refBtn = document.getElementById('refBtn');
    const refModal = document.getElementById('refModal');
    const refInput = document.getElementById('refInput');
    const refApply = document.getElementById('refApply');
    const refClose = document.getElementById('refClose');

    // --------- Note helpers (chromatic, sharps+flats) ----------
    const NOTE_SHARP = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
    const NOTE_FLAT  = ["C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"];

    function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

    // Convert frequency -> MIDI note number using A4 reference
    function freqToMidi(f){
      // MIDI 69 = A4
      return 69 + 12 * Math.log2(f / referenceA4);
    }

    function midiToFreq(m){
      return referenceA4 * Math.pow(2, (m - 69) / 12);
    }

    function midiToName(midi, preferFlats){
      const n = Math.round(midi);
      const octave = Math.floor(n / 12) - 1;
      const idx = (n % 12 + 12) % 12;
      const name = preferFlats ? NOTE_FLAT[idx] : NOTE_SHARP[idx];
      return { name, octave, idx, midiRounded: n };
    }

    // cents difference between frequency and target
    function centsDiff(freq, target){
      return 1200 * Math.log2(freq / target);
    }

    // --------- Meter zoom (dynamic range) ----------
    // Wide max ±150, then zoom in as |cents| decreases.
    function getZoomRange(absCents){
      // Starts at 150 (wide) and becomes narrower near center.
      if (absCents > 80) return 150;
      if (absCents > 40) return 80;
      if (absCents > 20) return 40;
      if (absCents > 10) return 20;
      if (absCents > 5)  return 10;
      return 5;
    }

    function drawScale(range){
      // marks every 10 cents for large ranges, then tighter
      scaleEl.innerHTML = "";
      let step = 10;
      if (range <= 20) step = 5;
      if (range <= 10) step = 2;
      if (range <= 5)  step = 1;

      for (let c = -range; c <= range; c += step){
        const mark = document.createElement("div");
        mark.className = (c === 0) ? "mark center" : "mark";
        // label only on major ticks
        const major = (range >= 80) ? 20 : (range >= 40 ? 10 : (range >= 20 ? 10 : (range >= 10 ? 5 : 2)));
        if (c === 0 || (Math.abs(c) % major === 0)){
          const lab = document.createElement("span");
          lab.className = "label";
          lab.textContent = c;
          mark.appendChild(lab);
        }
        scaleEl.appendChild(mark);
      }
    }

    // --------- Stability / smoothing (reduce sensitivity) ----------
    // We smooth frequency and hold a stable note to avoid “jumping”
    let smoothFreq = null;
    let lastStableMidi = null;
    let stableFrames = 0;
    const STABLE_FRAMES_REQUIRED = 4;   // increase => less jumpy
    const NOTE_HYSTERESIS_CENTS = 18;   // must drift > this to switch note

    // Gate / confidence
    const RMS_MIN = 0.018;        // volume threshold (raise to ignore noise)
    const CONF_MIN = 0.65;        // confidence threshold

    // Prefer flats display when near Db/Eb/Gb/Ab/Bb? -> user asked both; we show both when applicable
    function formatNameBoth(midi){
      const sharp = midiToName(midi, false);
      const flat  = midiToName(midi, true);

      // If sharp and flat differ (C# vs Db), show both
      if (sharp.name !== flat.name){
        return `${sharp.name}${sharp.octave} / ${flat.name}${flat.octave}`;
      }
      return `${sharp.name}${sharp.octave}`;
    }

    // --------- Pitch detection (improved autocorrelation + confidence) ----------
    function autoCorrelateFloat32(buf, sampleRate){
      // This version returns {freq, confidence, rms} with stronger noise rejection
      const SIZE = buf.length;
      let rms = 0;
      for (let i=0;i<SIZE;i++){
        const v = buf[i];
        rms += v*v;
      }
      rms = Math.sqrt(rms / SIZE);
      if (rms < RMS_MIN) return { freq: -1, confidence: 0, rms };

      // remove DC offset
      let mean = 0;
      for (let i=0;i<SIZE;i++) mean += buf[i];
      mean /= SIZE;
      for (let i=0;i<SIZE;i++) buf[i] -= mean;

      const MAX_SAMPLES = Math.floor(SIZE/2);
      let bestOffset = -1;
      let bestCorr = 0;
      let lastCorr = 1;

      // We compute correlation based on squared difference (more stable than abs diff)
      for (let offset=16; offset < MAX_SAMPLES; offset++){
        let corr = 0;
        for (let i=0;i<MAX_SAMPLES;i++){
          const d = buf[i] - buf[i+offset];
          corr += d*d;
        }
        corr = 1 - (corr / MAX_SAMPLES); // normalize-ish

        // pick local rising peaks
        if (corr > 0.85 && corr > lastCorr){
          if (corr > bestCorr){
            bestCorr = corr;
            bestOffset = offset;
          }
        }
        lastCorr = corr;
      }

      if (bestOffset === -1 || bestCorr < 0.01) return { freq: -1, confidence: 0, rms };
      const freq = sampleRate / bestOffset;

      // Confidence scales with correlation and rms
      const confidence = clamp(bestCorr * (rms / 0.08), 0, 1);
      return { freq, confidence, rms };
    }

    // --------- UI update ----------
    let lastRange = 150;

    function setStatus(type, text){
      statusEl.className = "status" + (type ? (" " + type) : "");
      statusEl.textContent = text;
    }

    function updateUI(freq){
      // Convert to midi and nearest semitone target
      const midi = freqToMidi(freq);
      const midiRounded = Math.round(midi);
      const targetFreq = midiToFreq(midiRounded);
      const cents = centsDiff(freq, targetFreq);

      const absC = Math.abs(cents);
      const range = getZoomRange(absC);

      // redraw scale only if range changed
      if (range !== lastRange){
        lastRange = range;
        drawScale(range);
      }

      // Needle position
      const clampedC = clamp(cents, -range, range);
      const maxOffsetPct = 48;
      const offsetPct = (clampedC / range) * maxOffsetPct;
      needleEl.style.left = `calc(50% + ${offsetPct}%)`;

      // Needle color
      if (absC <= 3){
        needleEl.classList.add("ok");
      } else {
        needleEl.classList.remove("ok");
      }

      noteNameEl.textContent = formatNameBoth(midi);
      freqNowEl.textContent = `${freq.toFixed(2)} Hz`;
      deltaNowEl.textContent = `${cents >= 0 ? "+" : ""}${Math.round(cents)} cents`;

      if (absC <= 3){
        setStatus("good", "✓ Perfetto (±3 cents)");
      } else if (absC <= 8){
        setStatus(cents < 0 ? "low" : "high", cents < 0 ? "↓ Alza leggermente" : "↑ Abbassa leggermente");
      } else {
        setStatus(cents < 0 ? "low" : "high", cents < 0 ? "↓ Troppo bassa (tira)" : "↑ Troppo alta (molla)");
      }
    }

    // --------- Processing loop (analyser + RAF) ----------
    const FFT_SIZE = 2048;
    const BUF = new Float32Array(FFT_SIZE);

    function tick(){
      if (!isRunning) return;

      analyser.getFloatTimeDomainData(BUF);

      // copy because we DC-remove inside function (mutates buffer)
      const tmp = new Float32Array(BUF);
      const { freq, confidence, rms } = autoCorrelateFloat32(tmp, audioContext.sampleRate);

      // Frequency filter (general: allow wide range)
      const valid = (freq > 40 && freq < 2000 && confidence >= CONF_MIN);

      if (!valid){
        // If silence/noise: don’t jump; show listening state
        stableFrames = 0;
        setStatus("", "Ascolto… (suona una nota)");
        rafId = requestAnimationFrame(tick);
        return;
      }

      // smoothing
      const alpha = 0.22; // lower => more stable (less jump)
      smoothFreq = (smoothFreq == null) ? freq : (smoothFreq*(1-alpha) + freq*alpha);

      // stability / hysteresis on note switching
      const midiNow = freqToMidi(smoothFreq);
      const midiRounded = Math.round(midiNow);

      if (lastStableMidi == null){
        lastStableMidi = midiRounded;
        stableFrames = 1;
      } else {
        const targetFreqStable = midiToFreq(lastStableMidi);
        const centsFromStable = centsDiff(smoothFreq, targetFreqStable);

        // if still close to stable note, count frames
        if (Math.abs(centsFromStable) <= NOTE_HYSTERESIS_CENTS){
          stableFrames++;
        } else {
          // candidate new note — require stability a few frames
          stableFrames = Math.max(0, stableFrames - 1);
          if (stableFrames <= 0){
            lastStableMidi = midiRounded;
            stableFrames = 1;
          }
        }
      }

      // apply UI only when stable enough (reduces micro-jitter)
      if (stableFrames >= STABLE_FRAMES_REQUIRED){
        // use stable note target but actual smoothed freq
        updateUI(smoothFreq);
      } else {
        setStatus("", "Stabilizzo…");
      }

      rafId = requestAnimationFrame(tick);
    }

    // --------- Fullscreen helpers (must be user gesture) ----------
    async function enterFullscreen(){
      try{
        if (!document.fullscreenElement){
          await document.documentElement.requestFullscreen({ navigationUI: "hide" });
        }
      }catch(e){}
    }
    async function exitFullscreen(){
      try{
        if (document.fullscreenElement){
          await document.exitFullscreen();
        }
      }catch(e){}
    }

    // --------- Start / Stop ----------
    async function start(){
      overlayErr.style.display = "none";
      try{
        // get mic (user gesture comes from button tap)
        streamRef = await navigator.mediaDevices.getUserMedia({
          audio: {
            echoCancellation: false,
            noiseSuppression: false,
            autoGainControl: false
          }
        });

        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = FFT_SIZE;

        micSource = audioContext.createMediaStreamSource(streamRef);
        micSource.connect(analyser);

        // init
        isRunning = true;
        smoothFreq = null;
        lastStableMidi = null;
        stableFrames = 0;

        // UI
        startOverlay.style.display = "none";
        stopBtn.style.display = "inline-flex";
        setStatus("", "Ascolto… (suona una nota)");
        lastRange = 999; // force scale redraw
        drawScale(150);
        lastRange = 150;

        // fullscreen now (allowed because still in same user gesture)
        await enterFullscreen();

        // start loop
        if (rafId) cancelAnimationFrame(rafId);
        rafId = requestAnimationFrame(tick);

      }catch(err){
        console.error(err);
        overlayErr.textContent = "Permesso microfono negato o non disponibile. Controlla i permessi del browser (lucchetto) e riprova.";
        overlayErr.style.display = "block";
      }
    }

    function stop(){
      isRunning = false;
      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;

      try{ if (micSource) micSource.disconnect(); }catch(e){}
      try{ if (analyser) analyser.disconnect(); }catch(e){}
      try{ if (audioContext) audioContext.close(); }catch(e){}

      if (streamRef){
        try{ streamRef.getTracks().forEach(t => t.stop()); }catch(e){}
      }

      micSource = null; analyser = null; audioContext = null; streamRef = null;
      smoothFreq = null; lastStableMidi = null; stableFrames = 0;

      stopBtn.style.display = "none";
      setStatus("", "Fermato");
      noteNameEl.textContent = "—";
      freqNowEl.textContent = "— Hz";
      deltaNowEl.textContent = "0 cents";
      needleEl.style.left = "50%";
      needleEl.classList.remove("ok");

      // show overlay again
      startOverlay.style.display = "flex";
      exitFullscreen();
    }

    // --------- Reference UI ----------
    function setReference(val){
      referenceA4 = clamp(Number(val || 440), 380, 520);
      refVal.textContent = `${referenceA4.toFixed(1)} Hz`;
      overlayRef.textContent = `${referenceA4.toFixed(1)} Hz`;
      refInput.value = referenceA4.toFixed(1);
    }
    setReference(440);

    function openRefModal(){ refModal.classList.add("show"); }
    function closeRefModal(){ refModal.classList.remove("show"); }

    // Buttons
    overlayStartBtn.addEventListener("click", start);
    stopBtn.addEventListener("click", stop);

    overlayRefBtn.addEventListener("click", openRefModal);
    refBtn.addEventListener("click", openRefModal);

    refApply.addEventListener("click", () => {
      setReference(refInput.value);
      closeRefModal();
    });
    refClose.addEventListener("click", closeRefModal);

    // Close modal on background tap (optional)
    refModal.addEventListener("click", (e) => {
      if (e.target === refModal) closeRefModal();
    });

    // If user exits fullscreen manually, keep running but don’t break
    document.addEventListener("fullscreenchange", () => {
      // nothing required; overlay remains hidden while running
    });

    // Start overlay shown by default (required for mic + fullscreen)
    startOverlay.style.display = "flex";
  </script>
</body>
</html>
