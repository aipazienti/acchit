<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover" />
<title>maracanaudio – Accordatore Pro</title>

<meta name="theme-color" content="#000000">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<style>
*{margin:0;padding:0;box-sizing:border-box;}
html,body{width:100%;height:100%;background:#000;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;}
.app{position:fixed;inset:0;display:flex;background:radial-gradient(circle at center,#151515 0%,#000 70%);color:#fff;}
.tuner{flex:1;display:flex;flex-direction:column;align-items:stretch;justify-content:flex-start;padding:12px;gap:10px;}
.topRow{display:flex;justify-content:space-between;align-items:center;gap:8px;}
.pill{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:14px;background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.12);font-weight:900;}
.btn{border:none;cursor:pointer;padding:10px 14px;border-radius:14px;font-weight:900;color:#fff;background:#2a5298;transition:transform .12s ease;user-select:none;}
.btn:active{transform:scale(0.98);}
.btn.secondary{background:rgba(255,255,255,0.12);}
.btn.danger{background:#dc3545;}
.readout{display:flex;flex-direction:column;align-items:center;gap:4px;padding-top:2px;}
.noteLine{font-size:48px;font-weight:1000;text-shadow:0 0 18px rgba(0,255,0,0.35);}
.freqLine{font-size:22px;font-weight:900;}
.deltaLine{font-size:18px;font-weight:900;color:#ffd700;}
.meter{position:relative;flex:1;min-height:140px;border-radius:18px;background:linear-gradient(180deg,rgba(255,255,255,0.06),rgba(255,255,255,0.02));border:1px solid rgba(255,255,255,0.12);overflow:hidden;}
.scale{position:absolute;inset:0;display:flex;justify-content:space-between;padding:0 24px;}
.mark{width:2px;background:rgba(255,255,255,0.2);position:relative;}
.mark.center{width:3px;background:#00ff00;box-shadow:0 0 16px rgba(0,255,0,0.6);}
.label{position:absolute;bottom:8px;left:50%;transform:translateX(-50%);font-size:12px;font-weight:900;opacity:0.7;white-space:nowrap;}
.needle{position:absolute;top:10%;height:80%;width:4px;left:50%;transform:translateX(-50%);border-radius:2px;background:#ff3333;box-shadow:0 0 16px rgba(255,0,0,0.6);transition:left .08s ease-out;}
.needle.ok{background:#00ff00;box-shadow:0 0 18px rgba(0,255,0,0.7);}
.status{text-align:center;padding:8px;border-radius:14px;font-weight:1000;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.12);}
.status.good{background:rgba(0,255,0,0.18);color:#d9ffd9;border-color:rgba(0,255,0,0.25);}
.status.low{background:rgba(255,68,68,0.18);border-color:rgba(255,68,68,0.25);}
.status.high{background:rgba(255,136,0,0.18);border-color:rgba(255,136,0,0.25);}

.overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.82);z-index:999;padding:14px;}
.overlayCard{width:min(520px,96vw);background:#fff;color:#111;border-radius:18px;padding:18px;box-shadow:0 18px 70px rgba(0,0,0,0.45);text-align:center;}
.overlayCard h2{font-size:20px;font-weight:1000;margin-bottom:8px;}
.overlayCard p{font-size:14px;font-weight:750;color:#444;line-height:1.4;margin-bottom:14px;}
.overlayRow{display:flex;gap:10px;justify-content:center;flex-wrap:wrap;}
.overlayRow .btn{min-width:160px;}
.err{display:none;margin-top:12px;color:#b00020;font-weight:900;font-size:13px;white-space:pre-wrap;}

.refModal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.72);z-index:1200;padding:14px;}
.refModal.show{display:flex;}
.refCard{width:min(520px,96vw);background:#fff;color:#111;border-radius:18px;padding:18px;text-align:left;box-shadow:0 18px 70px rgba(0,0,0,0.45);}
.refCard h3{font-size:18px;font-weight:1000;margin-bottom:10px;}
.refRow{display:flex;gap:10px;align-items:center;}
.refRow input{flex:1;padding:12px 12px;border-radius:14px;border:2px solid #ddd;font-size:16px;font-weight:900;outline:none;}
.hint{margin-top:10px;font-size:13px;font-weight:800;color:#555;}

.sensitivity-badge {
  display: inline-block;
  background: rgba(0,255,0,0.15);
  border-radius: 12px;
  padding: 2px 8px;
  font-size: 11px;
  font-weight: 900;
  color: #aaffaa;
  margin-left: 6px;
  border: 1px solid rgba(0,255,0,0.25);
}

@media (orientation:landscape) and (max-height:520px){
  .topRow{display:none;}
  .readout{gap:2px;}
  .noteLine{font-size:30px;}
  .freqLine{font-size:16px;}
  .deltaLine{font-size:14px;}
  .meter{flex:1;min-height:160px;}
  .status{font-size:14px;padding:6px;}
}
</style>
</head>

<body>
<div class="app">
  <div class="tuner" id="tunerRoot">
    <div class="topRow">
      <div class="pill">A4 <span id="refVal">440.0 Hz</span></div>
      <div style="display:flex;gap:8px;align-items:center;">
        <button class="btn secondary" id="refBtn">LA (A4)</button>
        <button class="btn danger" id="stopBtn" style="display:none;">STOP</button>
      </div>
    </div>

    <div class="readout">
      <div class="noteLine" id="noteName">—</div>
      <div class="freqLine" id="freqNow">— Hz</div>
      <div class="deltaLine" id="deltaNow">0 cents</div>
    </div>

    <div class="meter" id="meter">
      <div class="scale" id="scale"></div>
      <div class="needle" id="needle"></div>
    </div>

    <div class="status" id="status">Tocca AVVIA per iniziare</div>
  </div>
</div>

<div class="overlay" id="startOverlay">
  <div class="overlayCard">
    <h2>Accordatore <span class="sensitivity-badge">SENSIBILITÀ OTTIMIZZATA</span></h2>
    <p>
      Tocca “AVVIA” per attivare il microfono.<br/>
      LA di riferimento: <b id="overlayRef">440.0 Hz</b>
    </p>
    <div class="overlayRow">
      <button class="btn secondary" id="overlayRefBtn">Cambia LA</button>
      <button class="btn" id="startBtn">AVVIA</button>
    </div>
    <div class="err" id="overlayErr"></div>
  </div>
</div>

<div class="refModal" id="refModal">
  <div class="refCard">
    <h3>Imposta LA (A4) manualmente</h3>
    <div class="refRow">
      <input id="refInput" type="number" min="380" max="520" step="0.1" value="440.0" />
      <button class="btn" id="refApply">Applica</button>
    </div>
    <div class="hint">Suggeriti: 440 (standard), 432, 442.</div>
    <div style="display:flex;gap:10px;margin-top:12px;">
      <button class="btn secondary" id="refClose">Chiudi</button>
    </div>
  </div>
</div>

<script>
"use strict";


function showErr(msg){
  overlayErr.style.display = "block";
  overlayErr.textContent = msg;
}
function hideErr(){
  overlayErr.style.display = "none";
  overlayErr.textContent = "";
}


let audioContext, analyser, micSource, streamRef, rafId;
let isRunning = false;
let referenceA4 = 440.0;


const refVal = document.getElementById('refVal');
const overlayRef = document.getElementById('overlayRef');
const noteNameEl = document.getElementById('noteName');
const freqNowEl = document.getElementById('freqNow');
const deltaNowEl = document.getElementById('deltaNow');
const statusEl = document.getElementById('status');
const needleEl = document.getElementById('needle');
const scaleEl = document.getElementById('scale');
const stopBtn = document.getElementById('stopBtn');

const startOverlay = document.getElementById('startOverlay');
const startBtn = document.getElementById('startBtn');
const overlayRefBtn = document.getElementById('overlayRefBtn');
const overlayErr = document.getElementById('overlayErr');

const refBtn = document.getElementById('refBtn');
const refModal = document.getElementById('refModal');
const refInput = document.getElementById('refInput');
const refApply = document.getElementById('refApply');
const refClose = document.getElementById('refClose');


const NOTE_SHARP = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
const NOTE_FLAT  = ["C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"];
const clamp = (n,a,b)=>Math.max(a,Math.min(b,n));

function freqToMidi(f){ return 69 + 12*Math.log2(f/referenceA4); }
function midiToFreq(m){ return referenceA4*Math.pow(2,(m-69)/12); }
function midiToName(midi, preferFlats){
  const n=Math.round(midi);
  const octave=Math.floor(n/12)-1;
  const idx=(n%12+12)%12;
  const name=preferFlats?NOTE_FLAT[idx]:NOTE_SHARP[idx];
  return {name,octave};
}
function centsDiff(freq,target){ return 1200*Math.log2(freq/target); }
function formatNameBoth(midi){
  const s=midiToName(midi,false), f=midiToName(midi,true);
  if (s.name!==f.name) return `${s.name}${s.octave} / ${f.name}${f.octave}`;
  return `${s.name}${s.octave}`;
}


function getZoomRange(absC){
  if (absC>80) return 150;
  if (absC>40) return 80;
  if (absC>20) return 40;
  if (absC>10) return 20;
  if (absC>5)  return 10;
  return 5;
}
function drawScale(range){
  scaleEl.innerHTML="";
  let step=10;
  if(range<=20) step=5;
  if(range<=10) step=2;
  if(range<=5) step=1;

  for(let c=-range;c<=range;c+=step){
    const mark=document.createElement("div");
    mark.className=(c===0)?"mark center":"mark";
    const major=(range>=80)?20:(range>=40?10:(range>=20?10:(range>=10?5:2)));
    if(c===0 || (Math.abs(c)%major===0)){
      const lab=document.createElement("span");
      lab.className="label";
      lab.textContent=c;
      mark.appendChild(lab);
    }
    scaleEl.appendChild(mark);
  }
}


let smoothFreq=null, lastStableMidi=null, stableFrames=0;
const STABLE_FRAMES_REQUIRED=3; // Ridotto per maggiore reattività
const NOTE_HYSTERESIS_CENTS=12;  // Ridotto per maggiore precisione
const RMS_MIN=0.008; // SOGLIA MOLTO PIÙ BASSA per catturare anche suoni deboli
const CONF_MIN=0.55; // Leggermente ridotta per maggiore sensibilità

// Frequenze delle note della scala cromatica (basate su A4=440Hz)
const CHROMATIC_FREQS = [];
for (let midi = 21; midi <= 108; midi++) { // Da A0 a C8
  CHROMATIC_FREQS.push(midiToFreq(midi));
}

// Funzione migliorata di autocorrelazione con filtraggio passa-banda
function enhancedAutoCorrelate(buf, sr){
  const SIZE = buf.length;
  
  // Calcola RMS con finestra mobile per ridurre il rumore
  let rms = 0;
  let sum = 0;
  for(let i = 0; i < SIZE; i++) { 
    const v = buf[i]; 
    sum += v * v;
  }
  rms = Math.sqrt(sum / SIZE);
  
  // Soglia dinamica basata sul livello di rumore ambientale
  if(rms < RMS_MIN) return {freq: -1, confidence: 0, rms};
  
  // Sottrazione della media (DC offset)
  let mean = 0;
  for(let i = 0; i < SIZE; i++) mean += buf[i];
  mean /= SIZE;
  for(let i = 0; i < SIZE; i++) buf[i] -= mean;
  
  // Applica una finestra di Hamming per ridurre le discontinuità
  for(let i = 0; i < SIZE; i++) {
    buf[i] *= 0.54 - 0.46 * Math.cos(2 * Math.PI * i / (SIZE - 1));
  }
  
  const MAX_OFFSET = Math.floor(SIZE / 2);
  const MIN_OFFSET = Math.floor(sr / 2000); // minimo 20Hz
  const MAX_OFFSET_LIMIT = Math.floor(sr / 40); // massimo 40Hz
  
  let bestOffset = -1;
  let bestCorrelation = 0;
  let secondBestCorr = 0;
  let secondBestOffset = -1;
  
  // Cerca correlazione in range limitato per note musicali
  for(let offset = MIN_OFFSET; offset < MAX_OFFSET_LIMIT; offset++) {
    let correlation = 0;
    
    // Correlazione incrociata normalizzata
    let sum1 = 0, sum2 = 0, sum12 = 0;
    for(let i = 0; i < MAX_OFFSET; i++) {
      if(i + offset < SIZE) {
        sum12 += buf[i] * buf[i + offset];
        sum1 += buf[i] * buf[i];
        sum2 += buf[i + offset] * buf[i + offset];
      }
    }
    
    if (sum1 > 0 && sum2 > 0) {
      correlation = sum12 / Math.sqrt(sum1 * sum2);
    }
    
    // Pesa la correlazione per favorire offset vicini a note cromatiche
    if(correlation > bestCorrelation && correlation > 0.2) {
      const freq = sr / offset;
      
      // Verifica se la frequenza è vicina a una nota cromatica
      let minDistance = Infinity;
      for(let noteFreq of CHROMATIC_FREQS) {
        const ratio = freq / noteFreq;
        if (ratio > 0.8 && ratio < 1.2) {
          const distance = Math.abs(1200 * Math.log2(ratio));
          if (distance < minDistance) minDistance = distance;
        }
      }
      
      // Bonus per frequenze vicine a note cromatiche
      const chromaticBonus = (minDistance < 50) ? (1 - minDistance/200) : 0.5;
      const weightedCorr = correlation * (0.7 + 0.3 * chromaticBonus);
      
      if (weightedCorr > bestCorrelation) {
        secondBestCorr = bestCorrelation;
        secondBestOffset = bestOffset;
        bestCorrelation = weightedCorr;
        bestOffset = offset;
      }
    }
  }
  
  if(bestOffset === -1 || bestCorrelation < 0.15) {
    return {freq: -1, confidence: 0, rms};
  }
  
  // Interpolazione parabolica per maggiore precisione
  if (bestOffset > MIN_OFFSET && bestOffset < MAX_OFFSET_LIMIT - 1) {
    const c0 = bestCorrelation;
    const c1 = bestCorrelation; // semplificato per evitare ricalcoli
    const c2 = bestCorrelation;
    // Calcolo più preciso dell'offset
    const alpha = 0.5; // fattore di smoothing
    bestOffset = bestOffset + alpha * (secondBestOffset - bestOffset);
  }
  
  const freq = sr / bestOffset;
  const confidence = clamp(bestCorrelation * (rms / 0.03), 0, 1);
  
  // Validazione finale: deve essere vicino a una nota cromatica
  let isValidNote = false;
  let closestFreq = freq;
  let minDist = Infinity;
  
  for(let noteFreq of CHROMATIC_FREQS) {
    const ratio = freq / noteFreq;
    if (ratio > 0.95 && ratio < 1.05) {
      const dist = Math.abs(centsDiff(freq, noteFreq));
      if (dist < minDist) {
        minDist = dist;
        closestFreq = noteFreq;
        isValidNote = true;
      }
    }
  }
  
  if (isValidNote && minDist < 30) {
    // Correggi verso la nota più vicina se molto vicina
    const correctedFreq = (minDist < 5) ? closestFreq : freq;
    return {freq: correctedFreq, confidence, rms, corrected: true};
  }
  
  return {freq: isValidNote ? freq : -1, confidence: isValidNote ? confidence * 0.8 : 0, rms};
}


let lastRange=150;
function setStatus(type,text){
  statusEl.className="status"+(type?(" "+type):"");
  statusEl.textContent=text;
}
function updateUI(freq){
  const midi=freqToMidi(freq);
  const midiR=Math.round(midi);
  const target=midiToFreq(midiR);
  const cents=centsDiff(freq,target);
  const absC=Math.abs(cents);
  const range=getZoomRange(absC);

  if(range!==lastRange){ lastRange=range; drawScale(range); }

  const clamped=clamp(cents,-range,range);
  const maxPct=48;
  const pct=(clamped/range)*maxPct;
  needleEl.style.left=`calc(50% + ${pct}%)`;

  if(absC<=3) needleEl.classList.add("ok"); else needleEl.classList.remove("ok");

  noteNameEl.textContent=formatNameBoth(midi);
  freqNowEl.textContent=`${freq.toFixed(2)} Hz`;
  deltaNowEl.textContent=`${cents>=0?"+":""}${Math.round(cents)} cents`;

  if(absC<=3) setStatus("good","✓ Perfetto (±3 cents)");
  else if(absC<=8) setStatus(cents<0?"low":"high", cents<0?"↓ Alza leggermente":"↑ Abbassa leggermente");
  else setStatus(cents<0?"low":"high", cents<0?"↓ Troppo bassa (tira)":"↑ Troppo alta (molla)");
}


const FFT_SIZE = 4096; // RADDOPPIATO per maggiore risoluzione
const BUF = new Float32Array(FFT_SIZE);
const PROC_BUF = new Float32Array(FFT_SIZE); // Buffer separato per l'elaborazione

// Filtro passa-banda per frequenze musicali (80Hz - 1200Hz)
function bandpassFilter(buf, sr) {
  const filtered = new Float32Array(buf.length);
  const RC = 1 / (2 * Math.PI * 80); // Filtro passa-alto a 80Hz
  const dt = 1 / sr;
  const alpha = dt / (RC + dt);
  
  let y = buf[0];
  for (let i = 1; i < buf.length; i++) {
    y = alpha * (y + buf[i] - buf[i-1]);
    filtered[i] = y;
  }
  
  // Filtro passa-basso semplice
  const cutoff = 1200; // Hz
  const RC_low = 1 / (2 * Math.PI * cutoff);
  const alpha_low = dt / (RC_low + dt);
  
  let y_low = filtered[0];
  for (let i = 1; i < filtered.length; i++) {
    y_low = y_low + alpha_low * (filtered[i] - y_low);
    filtered[i] = y_low;
  }
  
  return filtered;
}

// Rilevamento picchi per eliminare rumori impulsivi
function removeSpikes(buf, threshold = 0.5) {
  const result = new Float32Array(buf.length);
  const mean = buf.reduce((a, b) => a + Math.abs(b), 0) / buf.length;
  const maxPeak = Math.max(...buf.map(Math.abs));
  
  if (maxPeak > mean * 10) { // Probabile spike
    for (let i = 0; i < buf.length; i++) {
      if (Math.abs(buf[i]) > mean * 5) {
        result[i] = (buf[i-1] + buf[i+1]) / 2; // Interpola
      } else {
        result[i] = buf[i];
      }
    }
    return result;
  }
  return buf;
}

function tick(){
  if(!isRunning) return;

  analyser.getFloatTimeDomainData(BUF);
  
  // Copia e pre-elabora
  let processedData = new Float32Array(BUF);
  
  // Rimuovi spikes
  processedData = removeSpikes(processedData);
  
  // Applica filtro passa-banda
  processedData = bandpassFilter(processedData, audioContext.sampleRate);
  
  const {freq, confidence, rms} = enhancedAutoCorrelate(processedData, audioContext.sampleRate);

  // Rilevamento più sensibile ma focalizzato
  const valid = (freq > 65 && freq < 1200 && confidence >= CONF_MIN); // Range note strumentali

  if(!valid){
    stableFrames = Math.max(0, stableFrames - 1);
    if (stableFrames <= 0) {
      lastStableMidi = null;
      setStatus("", "Ascolto… (suona una nota)");
    }
    rafId = requestAnimationFrame(tick);
    return;
  }

  // Filtro smoothing adattivo basato su confidenza
  const alpha = 0.15 + (confidence * 0.1); // Più veloce se alta confidenza
  if (smoothFreq == null) {
    smoothFreq = freq;
  } else {
    smoothFreq = smoothFreq * (1 - alpha) + freq * alpha;
  }

  const midiNow = freqToMidi(smoothFreq);
  const midiR = Math.round(midiNow);

  if(lastStableMidi == null) { 
    lastStableMidi = midiR; 
    stableFrames = 1;
  } else {
    const target = midiToFreq(lastStableMidi);
    const centsFrom = centsDiff(smoothFreq, target);
    
    if(Math.abs(centsFrom) <= NOTE_HYSTERESIS_CENTS) {
      stableFrames = Math.min(stableFrames + 1, STABLE_FRAMES_REQUIRED + 2);
    } else {
      stableFrames = Math.max(0, stableFrames - 2);
      if(stableFrames <= 0) { 
        lastStableMidi = midiR; 
        stableFrames = 1;
      }
    }
  }

  if(stableFrames >= STABLE_FRAMES_REQUIRED) {
    updateUI(smoothFreq);
    setStatus("good", "Nota rilevata");
  } else {
    setStatus("", `Analisi... ${Math.floor(stableFrames/STABLE_FRAMES_REQUIRED*100)}%`);
  }

  rafId = requestAnimationFrame(tick);
}


async function enterFullscreen(){
  try{
    if(!document.fullscreenElement){
      await document.documentElement.requestFullscreen({navigationUI:"hide"});
    }
  }catch(e){}
}
async function exitFullscreen(){
  try{ if(document.fullscreenElement) await document.exitFullscreen(); }catch(e){}
}


async function start(){
  hideErr();

  if (!window.isSecureContext) {
    showErr("ERRORE: microfono richiede HTTPS.\nApri la pagina su https:// (non file://).");
    return;
  }
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    showErr("ERRORE: getUserMedia non supportato dal browser.");
    return;
  }

  startBtn.disabled = true;
  startBtn.textContent = "AVVIO…";

  try{
    streamRef = await navigator.mediaDevices.getUserMedia({
      audio: { 
        echoCancellation: false, 
        noiseSuppression: false, // Mantenuto false per non alterare il suono
        autoGainControl: true,    // Attivato per migliorare il segnale debole
        sampleRate: { ideal: 48000 } // Frequenza di campionamento ideale
      }
    });

    audioContext = new (window.AudioContext || window.webkitAudioContext)({
      sampleRate: 48000, // Campionamento più alto per migliore risoluzione
      latencyHint: "playback"
    });

    if (audioContext.state === "suspended") {
      await audioContext.resume();
    }

    analyser = audioContext.createAnalyser();
    analyser.fftSize = FFT_SIZE;
    analyser.smoothingTimeConstant = 0; // Nessun smoothing per risposta immediata

    micSource = audioContext.createMediaStreamSource(streamRef);
    micSource.connect(analyser);

    isRunning = true;
    smoothFreq = null; 
    lastStableMidi = null; 
    stableFrames = 0;

    lastRange = 999;
    drawScale(150);
    lastRange = 150;

    setStatus("", "Ascolto… (suona una nota)");
    stopBtn.style.display = "inline-flex";

    startOverlay.style.display = "none";

    await enterFullscreen();

    if (rafId) cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(tick);

  }catch(err){
    console.error(err);
    const name = err && err.name ? err.name : "";
    let msg = "Permesso microfono negato/non disponibile.\n";
    if (name === "NotAllowedError" || name === "SecurityError") msg += "Consenti il microfono (lucchetto del browser) e ricarica.";
    else if (name === "NotFoundError") msg += "Nessun microfono rilevato sul dispositivo.";
    else if (name === "NotReadableError") msg += "Microfono occupato da un'altra app. Chiudi altre app e riprova.";
    else msg += "Riprova o cambia browser (Chrome/Edge/Safari).";
    showErr(msg);

    startOverlay.style.display = "flex";
  } finally {
    startBtn.disabled = false;
    startBtn.textContent = "AVVIA";
  }
}

function stop(){
  isRunning=false;
  if(rafId) cancelAnimationFrame(rafId);
  rafId=null;

  try{ if(micSource) micSource.disconnect(); }catch(e){}
  try{ if(audioContext) audioContext.close(); }catch(e){}
  if(streamRef){ try{ streamRef.getTracks().forEach(t=>t.stop()); }catch(e){} }

  micSource=null; analyser=null; audioContext=null; streamRef=null;
  smoothFreq=null; lastStableMidi=null; stableFrames=0;

  stopBtn.style.display="none";
  setStatus("", "Fermato");
  noteNameEl.textContent="—";
  freqNowEl.textContent="— Hz";
  deltaNowEl.textContent="0 cents";
  needleEl.style.left="50%";
  needleEl.classList.remove("ok");

  startOverlay.style.display="flex";
  exitFullscreen();
}


function setReference(val){
  referenceA4 = clamp(Number(val || 440), 380, 520);
  refVal.textContent = `${referenceA4.toFixed(1)} Hz`;
  overlayRef.textContent = `${referenceA4.toFixed(1)} Hz`;
  refInput.value = referenceA4.toFixed(1);
  
  // Ricostruisce le frequenze cromatiche con il nuovo riferimento
  CHROMATIC_FREQS.length = 0;
  for (let midi = 21; midi <= 108; midi++) {
    CHROMATIC_FREQS.push(midiToFreq(midi));
  }
}
setReference(440);

function openRefModal(){ refModal.classList.add("show"); }
function closeRefModal(){ refModal.classList.remove("show"); }


startBtn.addEventListener("click", start);
stopBtn.addEventListener("click", stop);

overlayRefBtn.addEventListener("click", openRefModal);
refBtn.addEventListener("click", openRefModal);

refApply.addEventListener("click", ()=>{ setReference(refInput.value); closeRefModal(); });
refClose.addEventListener("click", closeRefModal);
refModal.addEventListener("click", (e)=>{ if(e.target===refModal) closeRefModal(); });

document.addEventListener("visibilitychange", ()=>{ if(document.hidden && isRunning) stop(); });


startOverlay.style.display="flex";
</script>
</body>
</html>